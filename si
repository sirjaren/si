#!/bin/bash
#-------------------------------------------------------------------------------
# si - Parallel BASH commandline music image splitter to separate FLAC files
#-------------------------------------------------------------------------------
# Copyright (C) 2013  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/si
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#-------------------------------------------------------------------------------
# Enable BASH globstar
shopt -s globstar

# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2>/dev/null

# Hide the cursor
printf "\033[?25l"

# Current program version
version="0.1"

# Colors
blue="\033[34m"
green="\033[32m"
red="\033[31m"
cyan="\033[36m"
magenta="\033[35m"
yellow="\033[33m"
normal="\033[0m"

# Temporary FIFO location
tmp_fifo="/tmp/split_images_fifo_$$"

# Directory housing music image files
image_dir="${1%/}"

# Directory where split music file end up
split_dir="/media/Music_Library/Music/Split Music Files"

# Shnsplit flac encoder to use:
#  No SEEKTABLE block created
#  Fastest/Lowest compression: 1
#  Verify FLAC output (tests integrity)
#  Output to shnsplit as '%f' which is sent to STDOUT
shn_flac_enc="flac flac --no-seektable -1 -V -o %f -"

# Yellow message
__warn () {
	printf "${normal}%s${yellow}%s${normal}%s" \
	" " "*" " ${@}"
}

# Green message
__info () {
	printf "${normal}%s${green}%s${normal}%s" \
	" " "*" " ${@}"
}

# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${retag_flac}" == "true" ]] ; then
		__newline 2
	fi

	# Top title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"

	# Title
	printf "${normal}%s\n" \
	"                Runtime Information"

	# Bottom title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Script version
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"                  Version " "|" " " "${version}"

	# Processes to be used
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}%s${cyan}%s${normal}\n" \
	"            Parallel Jobs " "|" " " "${jobs}" " " "${jobs_display}"

	# Bottom banner line
	printf "${normal}%s${blue}%s${normal}\n\n" \
	" " "-------------------------+-------------------------"

	# Message indicating the searching of FLAC files
	__info "Finding music image files to process..."
}

# Display the summary of operations chart
__operation_summary () {
	# Title
	printf "\n${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"
	printf "${normal}%s\n" \
	"            Number Of Music Images Split"
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	if [[ -z "${flac_file[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"              " "FLAC Images" " " "|" " " "${#flac_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"              " "FLAC Images" " " "|" " " "${#flac_files[@]}"
	fi

	if [[ -z "${wav_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"               " "WAV Images" " " "|" " " "${#wav_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"               " "WAV Images" " " "|" " " "${#wav_files[@]}"
	fi

	if [[ -z "${ape_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"               " "APE Images" " " "|" " " "${#ape_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"               " "APE Images" " " "|" " " "${#ape_files[@]}"
	fi

	if [[ -z "${wv_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"                " "WV Images" " " "|" " " "${#wv_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"                " "WV Images" " " "|" " " "${#wv_files[@]}"
	fi

	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_files_ok () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"
	columns="${columns/%;*}"

	# ${images_ok_spacing} is the spacing from the number of
	# ${columns} minus the number of printed characters:
	#
	#  * Finding music iamge files to process... <- ${images_ok_spacing} -> [ ok ]
	#                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
	# 42 is the number of printed characters printed and is what is subtracted
	# from ${columns} to get ${images_ok_spacing}:
	#
	#  ' * Finding music image files to process...'  (42 characters)
	#                                     '[ ok ] '  ( 7 characters)
	printf "${normal}%$(( ${columns} - 49 ))s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}" \
	"" "[" " " "ok" " " "]"
}

# Prints the number of newlines specified
# by ${1}
__newline () {
	newlines="${1}"

	# If ${newlines} is empty, set to 1 in order
	# to allow one newline to be printed
	if [[ -z "${newlines}" ]] ; then
		newlines="1"
	fi

	# Print the number of newlines specified
	for (( count=0; count < ${newlines}; count++ )) ; do
		printf "\n"
	done
}

#-------------------------------------------------------------------------------
#  PROCESSED FILE MESSAGES
#-------------------------------------------------------------------------------
# Print out current file that is being split
__print_splitting_file () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of files processed
	#  ${total_files_length}:  Length of the total # of files to split
	#                     29:  Length of:
	#                            [ Splitting Image ] (19)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - ${total_files_length} - 29 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${#total_files[@]}]" " ${filename} " "" "[" " " "Splitting Image" " " "]" " "
}

# Print ok message
__print_ok () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of files processed
	#  ${total_files_length}:  Length of the total # of files to split
	#                     16:  Length of:
	#                            [ ok ] (6)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#iteration} - ${total_files_length} - 16 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${#total_files[@]}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# This is the function to run when a user invokes SIGINT during an operation
__operation_abort () {
	__newline
	__info "Control-C received. Please wait..." ; __newline

	# Kill running children
	__kill_jobs

	# Remove any temporary WAV files (if any)
	rm -f "${image_dir}"/**/\[[0-9]*\]_tmp_si_[0-9]*.wav

	# Restore old stty settings, make stty happy by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	exit 1
}

# Determine the width of the terminal in columns
__columns () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"

	# Prints out total columns of terminal
	printf "%s" "${columns/%;*}"
}

# Display current length spacing between filename and operation message
__current_length () {
	# The current length is obtained via the length of what's printed now minus
	# the length of the filename and gaps:
	#
	#  [1234/123456] 07 - Some_FLAC_Filename.flac <- ${current_length} -> [ Operation Message ]
	#                                             ^^^^^^^^^^^^^^^^^^^^^^^
	#  ${current_filename_length}:  Length of the current filename from __filename
	#  ${max_filename_length} + 1:  Total length of what's printed minus the operation
	#                               message plus one because we do not want the ellipsis
	#                               from ${max_filename_length}, just the space/gap
	#
	# Only print out ${current_length} if the current filename length is less
	# than the maximum file length allowed
	if [[ "${current_filename_length}" -lt "${max_filename_length}" ]] ; then
		printf "%s" "$(( ${max_filename_length} - ${current_filename_length} + 1 ))"
	fi
}

# Creates filename of current FLAC and culls it if the length
# is bigger than then width of the terminal
__filename () {
	filename="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	filename="${filename//$'\n'/?}"

	# Obtain filename length.  We cannot use ${#filename} in the event there is
	# multibyte characters -- the width would not be equal to characters since
	# the characters can take up more than one block in a terminal
	current_filename_length="$(wc -L <<< "${filename}")"

	# Cull filename and add an ellipsis if the filename is too long
	if [[ "${current_filename_length}" -gt "${max_filename_length}" ]] ; then
		filename="${filename::${max_filename_length}}…"
	fi
}

# Kill any child process
__kill_jobs () {
	# Hide error output in case there are no children to kill
	kill $(jobs -rp)

	# Wait on killing the children process, hiding STDERR to disable job control
	# output
	wait "${!}" 2>/dev/null
}

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if [[ "$(stat -c %d%D /proc)" == "$(stat -c %d%D /)" ]] ; then
		# /proc is not mounted, default to 2 jobs
		jobs_display="(Default)"
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs_display="(Default)"
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
			jobs_display="(/proc/cpuinfo)"
		fi
	fi
}

# Determine which operation should be run by file extension
__determine_operation () {
	case "${i##*.}" in
		[Ww][Aa][Vv])
			parallel_operation="__operation_wav"
		;;
		[Ww][Vv])
			parallel_operation="__operation_wv"
		;;
		[Ff][Ll][Aa][Cc])
			parallel_operation="__operation_flac"
		;;
		[Aa][Pp][Ee])
			parallel_operation="__operation_ape"
		;;
		*)
			__warn "Some unknown extension was found!  This is a bug!" ; __newline
		;;
	esac
}
# Clear old file descriptor (3) and create a new
# FIFO that's tied to file discriptor 3, removing
# the FIFO upon completion
__clear_tmp_fd () {
	# Create temporary FIFO
	mkfifo "${tmp_fifo}"

	# Open FIFO for reading and writing on file descriptor '3'
	exec 3<>"${tmp_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_fifo}"
}

# Function to run operations in parallel
__run_parallel_files () {
	# Forces iteration to start at 0, in the event that
	# multiple operations are going to be run
	iteration=0

	# Start as many processes as determined by ${jobs}
	for i in "${total_files[@]:0:${jobs}}" ; do

		# Check file extension, defining which operation should be run
		__determine_operation

		((iteration++))
		__print_splitting_file

		"${parallel_operation}" &
	done

	# If the FLAC files to process are greater than the # of ${jobs}
	# available, continue processing them, else quit
	if [[ "${#total_files[@]}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of FLACs to process is less than total FLACs
			# found, add another FLAC to process
			if [[ "${iteration}" -lt "$(( ${#total_files[@]} - 1 ))" ]] ; then
				i="${total_files[${iteration}]}"

				# Check file extension, defining which operation should be run
				__determine_operation

				((iteration++))
				__print_splitting_file

				"${parallel_operation}" &

			# Below is processed only if the current directory
			# is equal to the last ${flac_directories_array[@]} index
			else
				last_file="true"
				i="${total_files[${iteration}]}"

				# Check file extension, defining which operation should be run
				__determine_operation

				((iteration++))
				__print_splitting_file

				"${parallel_operation}" &

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	else
		last_file="true"
	fi

	# Wait for children processes
	wait
}

# Load up CUE file and obtain album tags
__load_cue () {
	# Grab pathname to directory housing image file
	directory="${i%/*}"

	# Find CUE files (first index)
	cue_file=( "${directory}"/**/*.[Cc][Uu][Ee] )

	# Album METADATA from CUE file
	#
	#
	# Load up CUE into array
	mapfile -n0 -t cue_array < "${cue_file[0]}"

	# Remove any carriage returns (if the CUE is from Windows)
	cue_array=( "${cue_array[@]//$'\r'/}" )

	# Run through CUE file (from array) and obtain album tags
	for tag in "${cue_array[@]}" ; do
		# Grab ARTIST tag
		if [[ "${tag}" == PERFORMER* ]] ; then
			ARTIST="${tag#*\"}"
			ARTIST="${ARTIST%\"}"

			if [[ -z "${ARTIST}" ]] ; then
				ARTIST="unknown_artist"
			fi
		fi

		# Grab ALBUM tag
		if [[ "${tag}" == TITLE* ]] ; then
			ALBUM="${tag#*\"}"
			ALBUM="${ALBUM%\"}"

			if [[ -z "${ALBUM}" ]] ; then
				ALBUM="unknown_album"
			fi
		fi

		# Grab DATE tag
		if [[ "${tag}" == 'REM DATE'* ]] ; then
			DATE="${tag#* * }"

			if [[ -z "${DATE}" ]] ; then
				DATE="unknown_date"
			fi
		fi

		# Grab GENRE tag
		if [[ "${tag}" == 'REM GENRE'* ]] ; then
			GENRE="${tag#* * }"
			GENRE="${GENRE#\"}"
			GENRE="${GENRE%\"}"

			if [[ -z "${GENRE}" ]] ; then
				GENRE="unknown_genre"
			fi
		fi
	done
}

# Split image file with 'shnsplit'
__split_file () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# The below 'shnsplit' command splits the music file:
	#
	#   -O always                 # Always overwrite files (if applicable)
	#   -q                        # Suppress STDOUT (STDERR still shown)
	#   -o "${shn_flac_enc}"      # Use defined FLAC encoder
	#   -f "${cue_file[0]}"       # CUE file location
	#   -t '%n - %t'              # Split files named (eg. 03 - TITLE.flac)
	#   -d "${full_split_dir}"    # Output directory of split files
	#   "${i}"                    # Music image file to split

	shnsplit \
		-O always \
		-q \
		-o "${shn_flac_enc}" \
		-f "${cue_file[0]}" \
		-t '%n - %t' \
		-d "${full_split_dir}" \
		"${i}"

	# Remove files with tracknumbers that are zero (eg '00'), since the CUE file
	# will choke on these files (not true songs)
	rm -f "${full_split_dir}"/00*.flac
}

# Tag the split music files
__tag_files () {
	# Run through each FLAC file that was split, obtaining the TRACKNUMBER
	# and TITLE tag from each file.  Once found, tag each FLAC file with the
	# following tags (if available from the CUE file):
	#   TITLE
	#   ARTIST
	#   ALBUM
	#   DATE
	#   TRACKNUMBER
	#   GENRE
	for file in "${full_split_dir}"/*.flac ; do

		# Get basename of FLAC
		file_basename="${file##*/}"

		# Use the first part of the filename as the TRACKNUMBER.  This is
		# to choose which TITLE to use in the CUE file
		TRACKNUMBER="${file_basename%% - *}"

		# Run through CUE file (from array) and obtain the current TITLE
		# tag based off the TRACKNUMBER obtained earlier
		for line in "${cue_array[@]}" ; do

			# If the previous iteration matched the TRACKNUMBER to the track
			# found in the CUE file, then ${track_found} was set to 'true',
			# making the next iteration display the TITLE tag information that
			# comes after the TRACKNUMBER tag information
			if [[ "${track_found}" == "true" ]] ; then

				# String line to just display the track TITLE
				TITLE="${line#*TITLE \"}"
				TITLE="${TITLE%\"}"

				# If TITLE tag is null, display unknown
				if [[ -z "${TITLE}" ]] ; then
					TITLE="unknown_title"
				fi

				# Tag the current FLAC file with the obtained tags
				metaflac \
					--set-tag=TITLE="${TITLE}" \
					--set-tag=ARTIST="${ARTIST}" \
					--set-tag=ALBUM="${ALBUM}" \
					--set-tag=DATE="${DATE}" \
					--set-tag=TRACKNUMBER="${TRACKNUMBER}" \
					--set-tag=GENRE="${GENRE}" \
					"${file}"

					# Reset ${track_found} value to enforce any previous value
					# will be discarded on future tests
					track_found=""

			# TRACKNUMBER was not found in the previous line in the CUE file, so
			# try the next line
			else

				# Check for the TRACKNUMBER in the current line
				if [[ "${line#  TRACK }" == ${TRACKNUMBER}* ]] ; then

					# TRACK was found with current TRACKNUMBER, continue
					# to the next loop iteration
					track_found="true"
					continue
				fi
			fi
		done
	done
}

# Split FLAC images
__operation_flac () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive SIGTERM from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Test FLAC file and send to background to allow killing on SIGTERM
	flac -t --totally-silent "${i}" &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "${i#**/} failed testing" ; __newline
	fi

	# Load up CUE file and obtain album tags
	__load_cue

#	BITS="$(metaflac --show-bps "$i")"
#	SAMPLE_RATE="$(metaflac --show-sample-rate "$i")"
#	if [[ $SAMPLE_RATE -gt 44100 || $BITS -gt 16 ]] ; then
		# Higher than CD quality (16bit/44.1kHz) so change CUE file
		# from mm:ss:ff to mm:ss.nnn (frames/sec to milliseconds)
#		grep -o "..:..:.." "$LOCAL_DIR"/*.cue | sed 1d | while read i ; do
#			MM_SS="$(echo "$i" | grep -o "^..:..")"
#			FF="$(echo "$i" | sed 's/^..:..://')"
#			NNN="$(echo "scale=3 ; ((("$FF" + 1) / 75) * 1000 - 1)" | bc -l | sed 's/\..*//')"
#			NNN_CHARS="$(echo -n $NNN | wc -m)"
#			case $NNN_CHARS in
#				3)
					# eg 483, so do nothing
#					;;
#				2)
					# eg 24, so add one zero in front
#					NNN="0${NNN}"
#					;;
#				1)
					# eg 8, so add two zeros in front
#					NNN="00${NNN}"
#					;;
#				*)
					# shouldn't happen, exit 1
#					echo "SOMETHING'S WRONG!!!! CHECK CUE!!"
#					exit 1
#					;;
#			esac
			# Echo new index (mm:ss.nnn) to be parsed by shsplit
#			echo "${MM_SS}.${NNN}"
#		done | shnsplit -O always -q -o flac -d "$MUSIC_DIR"/"$ARTIST"/"$DATE - $ALBUM" "$i"
#	else

#	fi

	# Create split files directory using tags obtained from the CUE file
	full_split_dir="${split_dir}/${ARTIST}/${DATE} - ${ALBUM}"
	mkdir -p "${full_split_dir}"

	# Split image file with 'shnsplit' and send to background to allow killing
	# on SIGTERM
	__split_file &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed to split ${i#**/}." ; __newline
		__warn "${i#**/} may be corrupt." ; __newline
	fi

	# Tag the split music files
	__tag_files

	# Print newline into FIFO after completion
	__newline >&3
}

# Split WAV images
__operation_wav () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive SIGTERM from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Load up CUE file and obtain album tags
	__load_cue

	# Create split files directory using tags obtained from the CUE file
	full_split_dir="${split_dir}/${ARTIST}/${DATE} - ${ALBUM}"
	mkdir -p "${full_split_dir}"

	# Split image file with 'shnsplit' and send to background to allow killing
	# on SIGTERM
	__split_file &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed to split ${i#**/}." ; __newline
		__warn "${i#**/} may be corrupt." ; __newline
	fi

	# Tag the split music files
	__tag_files

	# Print newline into FIFO after completion
	__newline >&3

}

# Split WavPack images
__operation_wv () {
	# Find the directory path of the current file
	file_path_dir="${i%/*}"

	# The temporary WAV file to be created
	tmp_wav="${file_path_dir}/[${iteration}]_tmp_si_$$.wav"

	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive SIGTERM from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Test WavPack file and send to background to allow killing on SIGTERM
	wvunpack -qv "${i}" 2>/dev/null &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "${i#**/} failed testing" ; __newline
	fi

	# Decompress WavPack file to WAV to allow processing by 'shnsplit', sending
	# process to background to allow killing on SIGTERM
	wvunpack -q "${i}" -o "${tmp_wav}" 2>/dev/null &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed creating WAV file from ${i#**/}!" ; __newline
		__warn "${i#**/} may be corrupt!" ; __newline
	fi

	# Keep a copy of ${i} for error logging
	old_i="${i}"

	# Set ${i} to the newly created WAV file as this will be used for splitting
	i="${tmp_wav}"

	# Load up CUE file and obtain album tags
	__load_cue

	# Create split files directory using tags obtained from the CUE file
	full_split_dir="${split_dir}/${ARTIST}/${DATE} - ${ALBUM}"
	mkdir -p "${full_split_dir}"

	# Split image file with 'shnsplit' and send to background to allow killing
	# on SIGTERM
	__split_file &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed to split ${old_i#**/}." ; __newline
		__warn "${old_i#**/} may be corrupt." ; __newline
	fi

	# Tag the split music files
	__tag_files

	# Remove temporary WAV file
	rm -f "${tmp_wav}"

	# Print newline into FIFO after completion
	__newline >&3
}

# Split APE images
__operation_ape () {
	# Find the directory path of the current file
	file_path_dir="${i%/*}"

	# The temporary WAV file to be created
	tmp_wav="${file_path_dir}/[${iteration}]_tmp_si_$$.wav"

	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive SIGTERM from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Test Monkey's Audio file and send to background to allow killing on
	# SIGTERM
	mac "${i}" -q >/dev/null 2>&1 &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -ne 0 && "${?}" -ne 130 ]] ; then
		__warn "${i#**/} failed testing" ; __newline
	fi

	# Decompress Monkey's Audio file to WAV to allow processing by 'shnsplit',
	# sending process to background to allow killing on SIGTERM
	mac "${i}" "${tmp_wav}" -d >/dev/null 2>&1

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed creating WAV file from ${i#**/}!" ; __newline
		__warn "${i#**/} may be corrupt!" ; __newline
	fi

	# Keep a copy of ${i} for error logging
	old_i="${i}"

	# Set ${i} to the newly created WAV file as this will be used for splitting
	i="${tmp_wav}"

	# Load up CUE file and obtain album tags
	__load_cue

	# Create split files directory using tags obtained from the CUE file
	full_split_dir="${split_dir}/${ARTIST}/${DATE} - ${ALBUM}"
	mkdir -p "${full_split_dir}"

	# Split image file with 'shnsplit' and send to background to allow killing
	# on SIGTERM
	__split_file &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed to split ${old_i#**/}." ; __newline
		__warn "${old_i#**/} may be corrupt." ; __newline
	fi

	# Tag the split music files
	__tag_files

	# Remove temporary WAV file
	rm -f "${tmp_wav}"

	# Print newline into FIFO after completion
	__newline >&3

}

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
else
	jobs_display="(User Defined)"
fi

# Display top banner
__top_banner

# Various music files
wav_files=( "${image_dir}"/**/*.[Ww][Aa][Vv] )
wv_files=( "${image_dir}"/**/*.[Ww][Vv] )
flac_files=( "${image_dir}"/**/*.[Ff][Ll][Aa][Cc] )
ape_files=( "${image_dir}"/**/*.[Aa][Pp][Ee] )

# This displays '[ ok ]' after 'Finding musci image files to process...'
__processed_files_ok

# Test if there were any of the above file formats found, and if so add them to
# the ${total_files[@]} array
if [[ -f "${wav_files[0]}" ]] ; then
	total_files+=( "${wav_files[@]}" )
else
	wav_files=()
fi

if [[ -f "${wv_files[0]}" ]] ; then
	total_files+=( "${wv_files[@]}" )
else
	wv_files=()
fi

if [[ -f "${flac_files[0]}" ]] ; then
	total_files+=( "${flac_files[@]}" )
else
	flac_files=()
fi

if [[ -f "${ape_files[0]}" ]] ; then
	total_files+=( "${ape_files[@]}" )
else
	ape_files=()
fi

# Length of the total number of music images to split
total_files_length="${#total_files[@]}"
total_files_length="${#total_files_length}"

# Process music image files
if [[ -z "${total_files[@]}" ]] ; then
	__warn "There are not any music images to process!" ; __newline
else
	__newline
	__info "Splitting music image files..." ; __newline

	# Trap SIGINT (Control-C) to abort cleanly
	trap '__operation_abort 2>/dev/null' SIGINT

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Run parallel operations, that which is specified as ${1}
	__run_parallel_files

	if [[ "${last_file}" == "true" ]] ; then
		# Music image split successfully, printing only if it's the last file
		__print_ok ; __newline
	fi
fi

__operation_summary

# Restore old stty settings, make stty happy by redirecting /dev/stderr
stty ${old_stty} < /dev/stderr

# Restore the cursor
printf "\033[?25h"
