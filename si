#!/usr/bin/env bash
#-------------------------------------------------------------------------------
# si - Parallel BASH commandline music image splitter to separate FLAC files
#-------------------------------------------------------------------------------
# Copyright (C) 2013  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/si
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#    4: Spinner PID
#-------------------------------------------------------------------------------
# .: BASH OPTIONS :.
#-------------------------------------------------------------------------------
# Enable BASH globstar
shopt -s globstar

# Enable BASH extended globbing
shopt -s extglob

#== .: END BASH OPTIONS :. =====================================================


#-------------------------------------------------------------------------------
# .: SCRIPT MESSAGES :.
#-------------------------------------------------------------------------------
# Red message
__error () {
	printf "${normal}%s${red}%s${normal}%s" \
	" " "*" " ${@}"
}

# Yellow message
__warn () {
	printf "${normal}%s${yellow}%s${normal}%s" \
	" " "*" " ${@}"
}

# Green message
__info () {
	printf "${normal}%s${green}%s${normal}%s" \
	" " "*" " ${@}"
}

# Display (in bold red) message that system is missing vital programs
__display_missing_commands_header () {
	{ __error "You seem to be missing one or more necessary programs" ; __newline ;} >&2
	{ __error "to run this script reliably.  Below shows the program(s)" ; __newline ;} >&2
	{ __error "missing, as well as where you can install them from:" ; __newline 2 ;} >&2
}

# Display a lot of help
__long_help () {
	long_help=".TH \"SI\" 1
.SH NAME
si \\- Parallel BASH commandline music image splitter to separate FLAC files
.SH SYNOPSIS
.B si
.RI [options]
.RI [directory]
.RI [target_directory]
.RI ...
.SH DESCRIPTION
si is a BASH commandline program to split a variety of music image files
(currently FLAC, WV, APE, and WAV) into separate FLAC files using the original
music image's CUE file.  One of the key features of si is it's ability to
process a great number of music images in parallel, using as many jobs to
complete an operation as possible, very similar to 'GNU make'.
.SH USAGE
Running si is pretty straightforward, with the user specifying the directory
where music image files are located and then the user specifying the directory
where the split FLAC files will reside.  Example:

        \`si -j4 music_images_dir split_files_dir'
.SH OPTIONS
.TP
.BI -j[N], --jobs[=N]
Set the number of parallel jobs to run on script invocation.  If this is not
set, this script will attempt to find the number of CPU cores available, using
the number found as the number of parallel jobs to run.

If the script is unable to find the number of CPU cores available, the number of
jobs will be set to two (2) by default.
.TP
.BI -n, --no-color
Turn off color output.
.TP
.BI -v, --version
Display script version and exit.
.TP
.BI -h, --help
Shows this help message.
.SH BUGS
If you find a bug, please report it at:
<\\fBhttps://github.com/sirjaren/si/issues/new\\fP>
.SH AUTHOR
Jaren Stangret <sirjaren@gmail.com>
.SH THANKS
Thanks to all the people that provided feedback and support
.br
.SH REVISION
[ 1 ]"

	# Print out help to temporary file which will read by 'man'
	printf "%s\n" "${long_help}" > "${tmp_man_page}"
}

# Display short help
__short_help () {
	printf "%s\n" " Usage: si [options] [directory] [target_directory] ..."
	printf "%s\n" " Options:"
	printf "%s\n" "   -j[N], --jobs[=N]"
	printf "%s\n" "   -n, --no-color"
	printf "%s\n" "   -v, --version"
	printf "%s\n" "   -h, --help"
	printf "%s\n" " This is the short help; for details use 'si --help' or 'si -h'"
}

# Display usage
__usage () {
	printf "%s\n" " Usage: si [options] [directory] [target_directory] ..."
}

#== .: END MESSAGES :. =========================================================


#-------------------------------------------------------------------------------
# .: BANNERS :.
#-------------------------------------------------------------------------------
# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${retag_flac}" == "true" ]] ; then
		__newline 2
	fi

	# Top title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"

	# Title
	printf "${normal}%s\n" \
	"                Runtime Information"

	# Bottom title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Script version
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"                  Version " "|" " " "${version}"

	# Processes to be used
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}%s${cyan}%s${normal}\n" \
	"            Parallel Jobs " "|" " " "${jobs}" " " "${jobs_display}"

	# Bottom banner line
	printf "${normal}%s${blue}%s${normal}\n\n" \
	" " "-------------------------+-------------------------"

	# Message indicating the searching of FLAC files
	__info "Finding music image files to process..."
}

# Display the summary of operations chart
__operation_summary () {
	# Title
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"
	printf "${normal}%s\n" \
	"            Number Of Music Images Split"
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	if [[ -z "${flac_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"              " "FLAC Images" " " "|" " " "${#flac_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"              " "FLAC Images" " " "|" " " "${#flac_files[@]}"
	fi

	if [[ -z "${wav_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"               " "WAV Images" " " "|" " " "${#wav_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"               " "WAV Images" " " "|" " " "${#wav_files[@]}"
	fi

	if [[ -z "${ape_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"               " "APE Images" " " "|" " " "${#ape_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"               " "APE Images" " " "|" " " "${#ape_files[@]}"
	fi

	if [[ -z "${wv_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"                " "WV Images" " " "|" " " "${#wv_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"                " "WV Images" " " "|" " " "${#wv_files[@]}"
	fi

	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	#---------------------------------------------------------------------------
	# .: CLEANUP SECTION :.
	#---------------------------------------------------------------------------
	# Kill spinner process
	#
	# Obtain process PID of spinner
	mapfile -n1 -t -u4 spinner_pid

	# Kill spinner PID
	kill "${spinner_pid[0]}"

	# Restore old stty settings, make stty happy by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	#== .: END CLEANUP SECTION :. ==============================================
}

#== .: END BANNERS :. ==========================================================


#-------------------------------------------------------------------------------
# .: PROCESSED FILE MESSAGES :.
#-------------------------------------------------------------------------------
# Print out spinner
__spinner () {
	# Array houses various spinner incarnations
	spinner=( '|' '/' '-' '\' )

	# Run indefinitely
	while true; do
		# Print each index of the spinner array
		for i in "${spinner[@]}" ; do
			printf "\r ${cyan}%s${normal} " "${i}"

			# Sleep so the spinner isn't exceptionally fast
			sleep .1
		done
	done
}

# Print out current file that is being split
__print_splitting_file () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of files processed
	#  ${total_files_length}:  Length of the total # of files to split
	#                     29:  Length of:
	#                            [ Splitting Image ] (19)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#count} - ${total_files_length} - 29 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${count}/${#total_files[@]}]" " ${filename} " "" "[" " " "Splitting Image" " " "]" " "
}

# Print ok message
__print_splitting_ok () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of files processed
	#  ${total_files_length}:  Length of the total # of files to split
	#                     16:  Length of:
	#                            [ ok ] (6)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#count} - ${total_files_length} - 16 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${count}/${#total_files[@]}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_files_ok () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"
	columns="${columns/%;*}"

	# ${images_ok_spacing} is the spacing from the number of
	# ${columns} minus the number of printed characters:
	#
	#  * Finding music iamge files to process... <- ${images_ok_spacing} -> [ ok ]
	#                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
	# 42 is the number of printed characters printed and is what is subtracted
	# from ${columns} to get ${images_ok_spacing}:
	#
	#  ' * Finding music image files to process...'  (42 characters)
	#                                     '[ ok ] '  ( 7 characters)
	printf "${normal}%$(( ${columns} - 49 ))s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}" \
	"" "[" " " "ok" " " "]"
}

#== .: END PROCESSED FILE MESSAGES :. ==========================================


#-------------------------------------------------------------------------------
# .: VARIOUS COMMANDS :.
#-------------------------------------------------------------------------------
# Display script version
__print_version () {
	printf "%s\n" "Version ${version}"
}

# Prints the number of newlines specified
# by ${1}
__newline () {
	newlines="${1}"

	# If ${newlines} is empty, set to 1 in order
	# to allow one newline to be printed
	if [[ -z "${newlines}" ]] ; then
		newlines="1"
	fi

	# Print the number of newlines specified
	for (( count=0; count < ${newlines}; count++ )) ; do
		printf "\n"
	done
}

# This is the function to run when a user invokes SIGINT during an operation
__operation_abort () {
	__newline
	__info "Control-C received. Please wait..." ; __newline

	# Kill running children
	__kill_jobs

	# Kill spinner process
	#
	# Obtain process PID of spinner
	mapfile -n1 -t -u4 spinner_pid

	# Kill spinner PID
	kill "${spinner_pid[0]}"

	# Remove any temporary WAV files (if any)
	rm -f "${split_dir}"/**/*_tmp_si_[0-9]*.wav

	# Restore old stty settings, make stty happy by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	exit 1
}

# Determine the width of the terminal in columns
__columns () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"

	# Prints out total columns of terminal
	printf "%s" "${columns/%;*}"
}

# Display current length spacing between filename and operation message
__current_length () {
	# The current length is obtained via the length of what's printed now minus
	# the length of the filename and gaps:
	#
	#  [1234/123456] 07 - Some_FLAC_Filename.flac <- ${current_length} -> [ Operation Message ]
	#                                             ^^^^^^^^^^^^^^^^^^^^^^^
	#  ${current_filename_length}:  Length of the current filename from __filename
	#  ${max_filename_length} + 1:  Total length of what's printed minus the operation
	#                               message plus one because we do not want the ellipsis
	#                               from ${max_filename_length}, just the space/gap
	#
	# Only print out ${current_length} if the current filename length is less
	# than the maximum file length allowed
	if [[ "${current_filename_length}" -lt "${max_filename_length}" ]] ; then
		printf "%s" "$(( ${max_filename_length} - ${current_filename_length} + 1 ))"
	fi
}

# Creates filename of current FLAC and culls it if the length
# is bigger than then width of the terminal
__filename () {
	filename="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	filename="${filename//$'\n'/?}"

	# Obtain filename length.  We cannot use ${#filename} in the event there is
	# multibyte characters -- the width would not be equal to characters since
	# the characters can take up more than one block in a terminal
	current_filename_length="$(wc -L <<< "${filename}")"

	# Cull filename and add an ellipsis if the filename is too long
	if [[ "${current_filename_length}" -gt "${max_filename_length}" ]] ; then
		filename="${filename::${max_filename_length}}…"
	fi
}

# Kill any child process
__kill_jobs () {
	# Hide error output in case there are no children to kill
	kill $(jobs -rp) 2>/dev/null

	# Wait on killing the children process, hiding STDERR to disable job control
	# output
	wait "${!}" 2>/dev/null
}

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if [[ "$(stat -c %d%D /proc)" == "$(stat -c %d%D /)" ]] ; then
		# /proc is not mounted, default to 2 jobs
		jobs_display="(Default)"
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs_display="(Default)"
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
			jobs_display="(/proc/cpuinfo)"
		fi
	fi
}

# Clear old file descriptor (3) and create a new
# FIFO that's tied to file discriptor 3, removing
# the FIFO upon completion
__clear_tmp_fd () {
	# Create temporary FIFO
	mkfifo "${tmp_fifo}"

	# Open FIFO for reading and writing on file descriptor '3'
	exec 3<>"${tmp_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_fifo}"
}

# Create spinner file descriptor (4) and create a new FIFO that's tied to file
# descriptor 4, removing the FIFO upon completion
__create_spinner_fd () {
	# Create temporary FIFO
	mkfifo "${spinner_fifo}"

	# Open FIFO for reading and writing on file descriptor '4'
	exec 4<>"${spinner_fifo}"

	# Remove temporary FIFO and leave just the file descriptor available
	rm -f "${spinner_fifo}"
}

#== .: END VARIOUS COMMANDS :. =================================================


#-------------------------------------------------------------------------------
# .: POSITIONAL PARAMETERS :.
#-------------------------------------------------------------------------------
# Obtain and process the positional parameters invoked with the script
__process_positional_parameters () {
	# If no arguments are made to the script show usage & short help
	if [[ "${#}" -eq 0 ]] ; then
		__short_help
		exit 1
	fi

	# Add case where only one argument is specified
	if [[ "${#}" -eq 1 ]] ; then
		case "${1}" in
			--version|-v)
				__print_version
				exit 0
			;;
			--help|-h)
				# Create the temporary file in which a man page will be
				# generated
				tmp_man_page="/tmp/si_man_$$.1"

				# Generate the man page to the above temporary location
				__long_help

				# Read the man page with 'man'
				man "${tmp_man_page}"

				# After reading, remove temporary file and exit
				rm -f "${tmp_man_page}"

				exit 0
			;;
		esac
	fi

	# Add case where two or more arguments are specified and the arguments
	# called are not to have anything after them
	if (( ${#} > 1 )) ; then
		case "${1}" in
			--version|-v)
				__usage >&2
				exit 1
			;;
			--help|-h)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Separate the long and short style arguments into their
	# own arrays as well as capture the last non-arguements, to
	# prevent multiple directories being called
	for i in "${@}" ; do
		if [[ "${i}" == --* ]] ; then
			long_style_arguments_array+=( "${i}" )
		elif [[ "${i}" == -* ]] ; then
			short_style_arguments_array+=( "${i}" )
		else
			non_arguments_array+=( "${i}" )
		fi
	done

	# If there are more than two (2) directories, exit script
	if (( ${#non_arguments_array[@]} > 2 )) ; then
		__usage >&2
		exit 1
	fi

	# If there were any long style arguments called, convert them to short
	# style in order for getopts to be able to process them correctly (ignoring
	# '--help', '--version', since this is taken this is taken care of above).
	# Add invalid arguments to it's own array
	if [[ -n "${long_style_arguments_array[@]}" ]] ; then
		for i in "${long_style_arguments_array[@]}" ; do
			case "${i}" in
				--no-color)
					converted_arguments_array+=( -n )
				;;
				--jobs=[0-9]*)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${i##*=}"
				;;
				--version)
					__usage >&2
					exit 1
				;;
				--help)
					__usage >&2
					exit 1
				;;
				*)
					# Set invalid argument into array
					invalid_arguments_array+=( "${i}" )
				;;
			esac
		done
	fi

	# If there were any short style arguments called, go through
	# them, adding the valid arguments to the "converted_arguments"
	# array and adding invalid arguments to it's own array
	if [[ -n "${short_style_arguments_array[@]}" ]] ; then
		while getopts ":nj:hvo" arguments "${short_style_arguments_array[@]}" ; do
			case "${arguments}" in
				n)
					converted_arguments_array+=( -n )
				;;
				j)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${OPTARG}"
					converted_arguments_array+=( -j )
				;;
				h)
					converted_arguments_array+=( -h )
				;;
				v)
					converted_arguments_array+=( -v )
				;;
				:)
					# Currently, this is just for '-j' so we can explicity specify it
					parameter_errors_array+=( "-${OPTARG} requires an integer after it (eg. -${OPTARG}11)." )
				;;
				?)
					# Set invalid argument from getopts into
					# array using ${OPTARG}
					invalid_arguments_array+=( "-${OPTARG}" )
				;;
			esac
		done
	fi

	# If there were invalid arguments called, display them and exit script
	if [[ -n "${invalid_arguments_array[@]}" || -n "${parameter_errors_array[@]}" ]] ; then
		__usage >&2

		if [[ -n "${invalid_arguments_array[@]}" ]] ; then
			__newline >&2
			__error "Invalid options:" >&2

			for i in "${invalid_arguments_array[@]}" ; do
				printf "%s" " ${i}" >&2
			done

			__newline >&2
		fi

		if [[ -n "${parameter_errors_array[@]}" ]] ; then
			__newline >&2

			for i in "${parameter_errors_array[@]}" ; do
				{ __error "${i}" ; __newline ;} >&2
			done
		fi

		exit 1
	fi

	# Run through all the converted arguments and set up the correct
	# values based on what the user called, thereby allowing the
	# script to process said values and execute the corresponding
	# functions
	for i in "${converted_arguments_array[@]}" ; do
		case "${i}" in
			-n)
				no_color="true"
			;;
			-j)
				# Do nothing, ${jobs} has already been stored
				# in previous getopts loop
				:
			;;
			-v)
				__usage >&2
				exit 1
			;;
			-h)
				__usage >&2
				exit 1
			;;
			*)
				# Should not ever happen!
				{ __error "This is a BUG! Please report to:" ; __newline ;} >&2
				{ printf "%s\n" "   https://github.com/sirjaren/redoflacs/issues/new" ;} >&2

				exit 1
			;;
		esac
	done

	# Put all the called arguments into an array
	called_arguments_array=( "${@}" )

	# Set the last two arguments as the two directories specified and remove the
	# ending slash (if any) to prevent double slashes from appearing because of
	# BASH's globstar.
	#
	# This only appears if the directories specified are the direct parent
	# directories to the music image files to be processed.
	#
	# BASH 4.2 allows negative indices (ie):
	#
	# split_dir="${called_arguments_array[-1]%/}"
	# image_dir="${called_arguments_array[-2]%/}"
	split_dir="${called_arguments_array[$(( ${#called_arguments_array[@]} - 1 ))]%/}"
	image_dir="${called_arguments_array[$(( ${#called_arguments_array[@]} - 2 ))]%/}"
}

#== .: END POSITIONAL PARAMETERS :. ============================================


#-------------------------------------------------------------------------------
# .: MISSING PROGRAMS :.
#-------------------------------------------------------------------------------
# Check for missing programs vital to this script
__check_missing_programs () {
	# Check if each command can be found in $PATH
	rm_exists="$(type -P rm)"
	sleep_exists="$(type -P sleep)"
	stty_exists="$(type -P stty)"
	mkfifo_exists="$(type -P mkfifo)"
	wc_exists="$(type -P wc)"
	metaflac_exists="$(type -P metaflac)"
	flac_exists="$(type -P flac)"
	mac_exists="$(type -P mac)"
	wvunpack_exists="$(type -P wvunpack)"
	iconv_exists="$(type -P iconv)"

	# Go through and test if each command was found (by displaying its $PATH).
	# If it's empty, add where you can find the package to an array to be
	# displayed.
	if [[ -z "${rm_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"rm\" with the \"coreutils\" package." )
	fi

	if [[ -z "${sleep_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"sleep\" with the \"coreutils\" package." )
	fi

	if [[ -z "${stty_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"stty\" with the \"coreutils\" package." )
	fi

	if [[ -z "${mkfifo_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"mkfifo\" with the \"coreutils\" package." )
	fi

	if [[ -z "${wc_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"wc\" with the \"coreutils\" package." )
	fi

	if [[ -z "${metaflac_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"metaflac\" with the \"flac\" package." )
	fi

	if [[ -z "${flac_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"flac\" with the \"flac\" package." )
	fi

	if [[ -z "${mac_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"mac\" with the \"mac\" package." )
	fi

	if [[ -z "${wvunpack_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"wvunpack\" with the \"wavpack\" package." )
	fi

	if [[ -z "${iconv_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"iconv\" with the \"glibc\" package." )
	fi

	# If all the programs above were found, continue with script.  Else
	# display warning and exit script, printing out which package has
	# the missing programs
	if [[ -n "${command_exists_array[@]}" ]] ; then
		__display_missing_commands_header

		# Iterate through array and print each value
		for i in "${command_exists_array[@]}" ; do
			{ __warn "${i}" ; __newline ;} >&2
		done

		exit 1
	fi
}

#== .: END MISSING PROGRAMS :. =================================================


#-------------------------------------------------------------------------------
# .: PARALLEL FUNCTION :.
#-------------------------------------------------------------------------------
# Function to run operations in parallel
__run_parallel () {
	# Forces count to start at 0, in the event that
	# multiple operations are going to be run
	count=0

	# Start as many processes as determined by ${jobs}
	for process in "${operations[@]:0:${jobs}}" ; do

		((count++))

		# Run the split operation
		__operation_split "${process}" &

		((iteration++))

	done

	# If the operations to process are greater than the # of ${jobs} available,
	# continue processing them, else quit
	if [[ "${#operations[@]}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of operations to process is less than total
			# operations available, add another operation to process
			if [[ "${iteration}" -lt "$(( ${#operations[@]} - 1 ))" ]] ; then

				((count++))

				# Run the split operation
				__operation_split "${operations[${iteration}]}" &

				((iteration++))

			# Below is processed only if the current process ie equal to the
			# last ${operations_to_run} index
			else

				last_operation="true"

				((count++))

				# Run the split operation
				__operation_split "${operations[${iteration}]}" &

				((iteration++))

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	else
		last_operation="true"
	fi

	# Wait for children processes
	wait
}

#== .: END PARALLEL FUNCTION :. ================================================


#-------------------------------------------------------------------------------
# .: ERROR FUNCTIONS :.
#-------------------------------------------------------------------------------
# Check for missing files that are in ${file_array[@]}
__check_missing_files () {
	# Check for the same filename inside the CUE
	for file in "${!file_array[@]}" ; do

		for index in "${!file_array[@]}" ; do
			if (( file != index )) ; then
				if [[ "${file_array[${file}]}" == "${file_array[${index}]}" ]] ; then
					__newline 2
					__error "The same filename is specified more than once in a CUE:" ; __newline
					__error "  ${cue%/*}/${file_array[${file}]}" ; __newline
					__error ; __newline
					__error "Check the CUE file and fix any issues, before running again:" ; __newline
					__error "  ${cue}" ; __newline

					exit 1
				fi
			fi
		done
	done

	# Check if all the files in the above array exist in the current
	# directory
	if [[ -n "${files_dont_exist[@]}" ]] ; then
		__error "In the directory:" ; __newline

		__error
			printf "%s${cyan}%s${normal}\n" \
			"  " "${dir}"

		__error ; __newline
		__error "The CUE file:" ; __newline

		__error
			printf "%s${cyan}%s${normal}\n" \
			"  " "${cue##*/}"

		__error ; __newline
		__error "Specifies one or more files to split that are NOT avaiable in the same" ; __newline
		__error "directory as the CUE file.  The missing file(s):" ; __newline

		for file in "${files_dont_exist[@]}" ; do
			printf "%s${red}%s${normal}%s${cyan}%s${normal}\n" \
			" " "*" "   " "${file}"
		done

		exit 1
	fi
}

#== .: END ERROR FUNCTIONS :. ==================================================


#-------------------------------------------------------------------------------
# .: CUE FUNCTIONS :.
#-------------------------------------------------------------------------------
# Grab the CUE header to allow each separate CUE to have the requisite
# information
__cue_header () {
	# Run through CUE array and store the first lines of the CUE file until the
	# first FILE is found.  This is the CUE header
	for line in "${!cue_array[@]}" ; do
		if [[ "${cue_array[${line}]}" != FILE* ]] ; then
			# Store the current line into array
			cue_header+=( "${cue_array[${line}]}" )

			# Store the index where the above line can be found
			# into an array
			cue_indices+=( "${line}" )
		else
			# The first file was listed in the CUE, so all the
			# header information has been obtained, break out of
			# the loop
			break
		fi
	done

	# Unset the header information from the CUE array
	for index in "${cue_indices[@]}" ; do
		unset -v cue_array[${index}]
	done

	# Remove empty indices by recreating/repacking array
	cue_array=( "${cue_array[@]}" )
}

# Load CUE array and remove carriage returns if any
__cue_array () {
	# Load up CUE into array
	mapfile -n0 -t cue_array < "${cue}"

	# Remove any carriage returns (if the CUE is from Windows)
	cue_array=( "${cue_array[@]//$'\r'/}" )
}

# Load filenames (FILE) from CUE file into array
__cue_filename () {
	# Check for multiple filenames in CUE array and store them in an
	# array
	for file in "${cue_array[@]}" ; do
		if [[ "${file}" == *FILE* ]] ; then
			file="${file#*FILE \"}"
			file="${file%\"*}"

			# Remove extension from file.  Loop twice for when a file name has
			# two extensions:
			#   <filename>.<WAV>.<EXTENSION>
			for i in {1..2} ; do
				file="${file%.[Aa][Pp][Ee]}"
				file="${file%.[Ff][Ll][Aa][Cc]}"
				file="${file%.[Ww][Vv]}"
				file="${file%.[Ww][Aa][Vv]}"
			done

			# Compare each audio file in the current directory to the file found
			# in the CUE array.  If a match is found, add to ${file_array}
			for current_file in "${tmp_total_files[@]##*/}" ; do

				# Remove extensions from current file in the directory, looping
				# twice in the event a file has two extensions like above
				for i in {1..2} ; do
					# ${i} is the ${current_file} with extensions removed
					i="${current_file%.[Aa][Pp][Ee]}"
					i="${i%.[Ff][Ll][Aa][Cc]}"
					i="${i%.[Ww][Vv]}"
					i="${i%.[Ww][Aa][Vv]}"
				done

				# Compare ${i} ( ${current_file} without extensions ), with the
				# file found in the CUE array
				if [[ "${i}" == "${file}" ]] ; then
					# ${current_file} is the filename WITH the extension
					file_array+=( "${current_file}" )
				fi
			done
		fi
	done
}

# Split CUE file into separate CUE files, each CUE file separated by FILE.  Each
# file found in a CUE is separated into a separate CUE file
__cue_split () {
	# Initialize cue file iteration to zero
	cue_iteration=0

	# Until CUE array is 0 (meaning all the files have been
	# processed), continue splitting all the files in the
	# CUE array to separate CUE files
	until [[ ${#cue_array[@]} -eq 0 ]] ; do

		# Go through each line in the CUE array, storing the
		# lines for each file into a separate CUE file
		for line in "${!cue_array[@]}" ; do

			# If the current line has a file in it and is NOT
			# the first FILE in the CUE array, add one to CUE
			# iteration
			if [[ "${cue_array[${line}]}" == FILE* && ${line} -ne 0 ]] ; then
				# A new file is found in the CUE array, break
				# out of loop and add one to the number of
				# files found
				((cue_iteration++))

				# Break out of loop
				break

			# If the index we are on is the last one of the
			# array, add one to the number of files found
			elif [[ ${line} -eq $(( ${#cue_array[@]} - 1 )) ]] ; then
				# End of array, add one to the number of files
				# found
				((cue_iteration++))

				# Store line into the new CUE array
				new_cue+=( "${cue_array[${line}]}" )

				# Store the index for removal
				file_indices+=( "${line}" )

				# Break out of loop
				break

			# If the line to process is blank, store the index
			elif [[ -z "${cue_array[${line}]}" ]] ; then
				# Blank line, just store the index for removal
				file_indices+=( "${line}" )

			else
				# Store line into the new CUE array
				new_cue+=( "${cue_array[${line}]}" )

				# Store the index from where it was found
				file_indices+=( "${line}" )
			fi
		done

		# Add the CUE file (that was just split/obtained) to a new array as a
		# single index.  This will be used to loop over (each index is a CUE
		# file to process).  The quoted 'printf' command allows us to store
		# the CUE header and the entire ${new_cue} array as a single index
		multi_cue+=( "$(printf "%s\n%s\n" "${cue_header[@]}" "${new_cue[@]}")" )

		# Unset all the used indices
		for index in "${file_indices[@]}" ; do
			unset -v cue_array[${index}]
		done

		# Remove empty indices by recreating/repacking array
		cue_array=( "${cue_array[@]}" )

		# Clear arrays for next loop
		file_indices=()
		new_cue=()
		print_array=()
	done

	# Clear CUE header array in the event of more than one file to split
	cue_header=()
}

# Obtain filename from current CUE file
__cue_current_filename () {
	# Grab file to process
	if [[ "${line}" == *FILE* ]] ; then
		file="${line#*FILE \"}"
		file="${file%\"*}"

		# Remove extension from file.  Loop twice for when a file name has
		# two extensions:
		#   <filename>.<WAV>.<EXTENSION>
		for i in {1..2} ; do
			file="${file%.[Aa][Pp][Ee]}"
			file="${file%.[Ff][Ll][Aa][Cc]}"
			file="${file%.[Ww][Vv]}"
			file="${file%.[Ww][Aa][Vv]}"
		done

		# Obtain all the possible kinds of image files in the current directory
		tmp_wav_files=( "${dir}"/*.[Ww][Aa][Vv] )
		tmp_wv_files=( "${dir}"/*.[Ww][Vv] )
		tmp_flac_files=( "${dir}"/*.[Ff][Ll][Aa][Cc] )
		tmp_ape_files=( "${dir}"/*.[Aa][Pp][Ee] )

		# Test if there were any of the above file formats found, and if so add them
		# to the ${total_files[@]} array
		if [[ -f "${tmp_wav_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_wav_files[@]}" )
		fi

		if [[ -f "${tmp_wv_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_wv_files[@]}" )
		fi

		if [[ -f "${tmp_flac_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_flac_files[@]}" )
		fi

		if [[ -f "${tmp_ape_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_ape_files[@]}" )
		fi

		# Compare each audio file in the current directory to the file found
		# in the CUE array.  If a match is found, add to ${file_array}
		for current_file in "${tmp_total_files[@]##*/}" ; do
			# Extension of the current file
			extension="${current_file##*.}"

			# Remove extensions from current file in the directory, looping
			# twice in the event a file has two extensions like above
			for j in {1..2} ; do
				# ${i} is the ${current_file} with extensions removed
				current_file="${current_file%.[Aa][Pp][Ee]}"
				current_file="${current_file%.[Ff][Ll][Aa][Cc]}"
				current_file="${current_file%.[Ww][Vv]}"
				current_file="${current_file%.[Ww][Aa][Vv]}"
			done

			# Compare ${current_file} (without extensions), with the
			# file found in the CUE array
			if [[ "${current_file}" == "${file}" ]] ; then
				# ${current_file} is the filename WITH the extension
				file="${current_file}.${extension}"
			fi
		done

		# Clear ${tmp_total_files}
		tmp_total_files=()
	fi
}

# Obtain ARTIST from current CUE file
__cue_artist () {
	# Grab ARTIST tag
	if [[ "${line}" == PERFORMER* ]] ; then
		ARTIST="${line#* }"

		# Remove quotes (if applicable)
		ARTIST="${ARTIST#\"}"
		ARTIST="${ARTIST%\"}"
	fi
}

# Obtain ALBUM from current CUE file
__cue_album () {
	# Grab ALBUM tag
	if [[ "${line}" == TITLE* ]] ; then
		ALBUM="${line#* }"

		# Remove quotes (if applicable)
		ALBUM="${ALBUM#\"}"
		ALBUM="${ALBUM%\"}"
	fi
}

# Obtain DATE from current CUE file
__cue_date () {
	# Grab DATE tag
	if [[ "${line}" == 'REM DATE'* ]] ; then
		DATE="${line##* }"

		# Remove quotes (if applicable)
		DATE="${DATE#\"}"
		DATE="${DATE%\"}"
	fi
}

# Obtain GENRE from current CUE file
__cue_genre () {
	# Grab GENRE tag
	if [[ "${line}" == 'REM GENRE'* ]] ; then
		GENRE="${line#* * }"

		# Remove quotes (if applicable)
		GENRE="${GENRE#\"}"
		GENRE="${GENRE%\"}"
	fi
}

# Check if CUE is neither ASCII or UTF8.  If not, then try to encode to
# UTF8, to help process files.  Normally, if not ASCII or UTF8, the encoding
# is CP1251 (Russian/Cyrillic), so we'll use CP1251 as the encoding from
# parameter to 'iconv'
__cue_encoding () {
	# Use 'file' to get a basic encoding of the file (not really reliable)
	encoding="$(file -ibN - < <(printf "%s\n" "${cue_array[@]}"))"

	# Strip mimetype and leave only the charset
	encoding="${encoding##*=}"

	# If the encoding is not ASCII or UTF-8, then convert the CUE array to UTF-8
	if [[ "${encoding}" != "us-ascii" || "${encoding}" != "utf-8" ]] ; then
		# Convert CUE array from CP1251 (hopefully) to UTF-8
		mapfile -n0 -t cue_array < \
		<(
			iconv --from-code CP1251 --to-code utf-8 <(printf "%s\n" "${cue_array[@]}")
		)
	fi
}

# Run through CUE array and replace certain characters
# Characters replaced:
#   ` -> '
#   / -> -
#   \ -> -
__cue_replace_characters () {
	character="'"
	cue_array=( "${cue_array[@]//\`/${character}}" )
	cue_array=( "${cue_array[@]//\//-}" )
	cue_array=( "${cue_array[@]//\\/-}" )
}

# Check for high resolution file and convert the INDEX time to milliseconds if
# necessary
__cue_milliseconds () {
	# Clear & initialize array
	high_res_cue=()

	# Run through the CUE array and for each line that is an INDEX, convert
	# the time from frames/sec to milliseconds storing the new index and CUE
	# sheet into a new array to be processed by 'shnsplit' as a temporary
	# CUE sheet
	for line in "${cue_array[@]}" ; do
		if [[ "${line}" == *INDEX* ]] ; then
			# Obtain just the time (eg 11:22:33) from the INDEX line
			index="${line##* }"

			# Store the INDEX line without the time (eg.
			# '    INDEX 01')
			index_string="${line% *}"

			# Minutes
			mm="${index%%:*}"

			# Seconds
			ss="${index#*:}"
			ss="${ss%:*}"

			# Frames (per second)
			ff="${index##*:}"

			# Milliseconds (converted from frames/sec)
			#   10#$(( ))             # Force base ten operation
			#   ( # of frames )       # Number of frames/sec
			#   * ( 1000 / 75 )       # Multiply by 1000 (milliseconds) and
			#                           divide by 75 frames
			#   printf -v nnn "%03d"  # Force a three digit number, prepended
			#                           with zeroes if less than three digits
			nnn=$(( 10#$(( ( ${ff#0} * 1000 / 75 ) )) ))

			# If milliseconds is greater than '999' (eg. '1234') then add
			# the first digit to seconds keep the last three digits as
			# milliseconds
			if (( nnn > 999 )) ; then
				# Add the first digit of milliseconds to seconds variable
				printf -v ss "%02d" "$(( 10#$((  ${ss#0} + ${nnn%???}  )) ))"

				# Cull the first digit of milliseconds
				nnn="${nnn#?}"
			else
				# Enforce milliseconds is a three digit number (prepended
				# with zeroes, if necessary)
				printf -v nnn "%03d" "${nnn}"
			fi

			# Store the INDEX line with new time into the high resolution array
			high_res_cue+=( "${index_string} ${mm}:${ss}.${nnn}" )
		else
			# Store the current line into the high resolution array
			high_res_cue+=( "${line}" )
		fi
	done

	# Set the CUE array to the high resolution version created
	cue_array=( "${high_res_cue[@]}" )
}

#== .: END CUE COMMANDS :. =====================================================


#-------------------------------------------------------------------------------
# .: PRELIMINARY OPERATIONS :.
#-------------------------------------------------------------------------------
# Obtain total files to process in the current directory
__total_files_directory () {
	# Obtain all the possible kinds of image files in the current directory
	tmp_wav_files=( "${dir}"/*.[Ww][Aa][Vv] )
	tmp_wv_files=( "${dir}"/*.[Ww][Vv] )
	tmp_flac_files=( "${dir}"/*.[Ff][Ll][Aa][Cc] )
	tmp_ape_files=( "${dir}"/*.[Aa][Pp][Ee] )

	# Test if there were any of the above file formats found, and if so add them
	# to the ${total_files[@]} array
	if [[ -f "${tmp_wav_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_wav_files[@]}" )
	fi

	if [[ -f "${tmp_wv_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_wv_files[@]}" )
	fi

	if [[ -f "${tmp_flac_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_flac_files[@]}" )
	fi

	if [[ -f "${tmp_ape_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_ape_files[@]}" )
	fi

	# Obtain all the CUE files in the current directory
	cue_files=( "${dir}"/*.[Cc][Uu][Ee] )

	if [[ ! -f "${cue_files[0]}" ]] ; then
		__newline 2 ; __error "In the directory:" ; __newline

		__error
			printf "%s${cyan}%s${normal}\n" \
			"  " "${dir}"

		__error ; __newline
		__error "There doesn't appear to be a CUE file in the above directory!"
		__newline 2

		exit 1
	fi
}

# Find all the various audio files to process, storing the found files in one
# centralized array
__obtain_audio_files () {
	wav_files=( "${image_dir}"/**/*.[Ww][Aa][Vv] )
	wv_files=( "${image_dir}"/**/*.[Ww][Vv] )
	flac_files=( "${image_dir}"/**/*.[Ff][Ll][Aa][Cc] )
	ape_files=( "${image_dir}"/**/*.[Aa][Pp][Ee] )

	# Test if there were any of the above file formats found, and if so add them
	# to the ${total_files[@]} array
	if [[ -f "${wav_files[0]}" ]] ; then
		total_files+=( "${wav_files[@]}" )
	else
		wav_files=()
	fi

	if [[ -f "${wv_files[0]}" ]] ; then
		total_files+=( "${wv_files[@]}" )
	else
		wv_files=()
	fi

	if [[ -f "${flac_files[0]}" ]] ; then
		total_files+=( "${flac_files[@]}" )
	else
		flac_files=()
	fi

	if [[ -f "${ape_files[0]}" ]] ; then
		total_files+=( "${ape_files[@]}" )
	else
		ape_files=()
	fi
}

# Obtain all the directories housing the music images to process
__obtain_directories () {
	for i in "${total_files[@]}" ; do
		if [[ "${processed_directory}" != "${i%/*}" ]] ; then
			total_directories+=( "${i%/*}" )
		fi
		processed_directory="${i%/*}"
	done
}

# Determine operation(s) to run
__determine_operation () {
	# Run through the total directories, determining which operation should be
	# performed based on the files found in each directory
	for dir in "${total_directories[@]}" ; do
		# Obtain total files to process in the current directory: ${dir}
		__total_files_directory

		# Check the number of CUE file and music image files in the current
		# directory, running a certain operation depending on the number(s)
		# found in the current directory
		#
		# If the number of music image files is GREATER than one
		if [[ ${#tmp_total_files[@]} -gt 1 ]] ; then

			#-------------------------------------------------------------------
			# .: MULTIPLE FILES -- MULTIPLE CUES :.
			#-------------------------------------------------------------------
			# If the number of CUE files is GREATER than one
			if [[ ${#cue_files[@]} -gt 1 ]] ; then

				# Obtain all the CUE files in the current directory
				cue_files=( "${dir}"/*.[Cc][Uu][Ee] )

				for cue in "${cue_files[@]}" ; do
					# Load and store CUE into array
					__cue_array

					# Load and store CUE filenames
					__cue_filename

					# Check for missing files that are in ${file_array[@]}
					__check_missing_files
				done

				for cue in "${cue_files[@]}" ; do
					# Load and store CUE into array
					__cue_array

					# Grab the CUE header to allow each separate CUE to have the
					# requisite information
					__cue_header

					# Split CUE file in array into separate CUE files to be used to split each
					# file listed in the separate CUE files
					__cue_split

					# If there are more than one CUE files (that were split),
					# determine the starting number, that split files start at
					# from the '-c' argument to 'shnsplit'
					if (( ${#multi_cue[@]} > 1 )) ; then
						# For each CUE that were split and stored as separate
						# indices, determine the operation to run
						for cue in "${multi_cue[@]}" ; do
							# Load the split CUE into a temporary array
							mapfile -n0 -t tmp_cue <<< "${cue}"

							# The split CUE is stored as a single index in an
							# array
							cue=( "$(printf "%s\n" "${cue}")" )

							# Add the operation to run to the array
							operations+=( "${dir} ::::@@si@@:::: ${cue}" )
						done
					else
						# Load the split CUE into a temporary array
						mapfile -n0 -t tmp_cue <<< "${cue}"

						# The split CUE is stored as a single index in an
						# array
						cue=( "$(printf "%s\n" "${multi_cue[@]}")" )

						# Add the operation to run to the array
						operations+=( "${dir} ::::@@si@@:::: ${cue}" )
					fi

					# Clear the multiple CUE array in the event that multiple
					# directories have multiple files in a CUE
					multi_cue=()
				done
			#== .: END MULTIPLE FILES -- MULTIPLE CUES :. ======================

			#-------------------------------------------------------------------
			# .: MULTIPLE FILES -- SINGLE CUE :.
			#-------------------------------------------------------------------
			else
				# Grab the path to the only CUE file and store it a variable
				cue=( "${dir}"/*.[Cc][Uu][Ee] )

				# Load and store CUE into array
				__cue_array

				# Load and store CUE filenames
				__cue_filename

				# Grab the CUE header to allow each separate CUE to have the
				# requisite information
				__cue_header

				# Check for missing files that are in ${file_array[@]}
				__check_missing_files

				# Split CUE file in array into separate CUE files to be used to split each
				# file listed in the separate CUE files
				__cue_split

				# If there are more than one CUE files (that were split),
				# determine the starting number split files start at from
				# the '-c' argument to 'shnsplit'
				if (( ${#multi_cue[@]} > 1 )) ; then
					# For each CUE that were split and stored as separate
					# indices, determine the operation to run
					for cue in "${multi_cue[@]}" ; do
						# Load the split CUE into a temporary array
						mapfile -n0 -t tmp_cue <<< "${cue}"

						# The split CUE is stored as a single index in an
						# array
						cue=( "$(printf "%s\n" "${cue}")" )

						# Add the operation to run to the array
						operations+=( "${dir} ::::@@si@@:::: ${cue}" )
					done
				else
					# Load the split CUE into a temporary array
					mapfile -n0 -t tmp_cue <<< "${cue}"

					# The split CUE is stored as a single index in an
					# array
					cue=( "$(printf "%s\n" "${multi_cue[@]}")" )

					# Add the operation to run to the array.  '-c' is
					# ${c} + 1
					operations+=( "${dir} ::::@@si@@:::: ${cue}" )
				fi
			fi
			#== .: END MULTIPLE FILES -- SINGLE CUE :. =========================

		#-----------------------------------------------------------------------
		# .: SINGLE FILE -- SINGLE/MULTIPLE CUE :.
		#-----------------------------------------------------------------------
		# There is only one music image file in the current directory.  The number
		# of CUE files does not matter since one or more is handled the same way
		else

			# Grab the path to only one CUE file and store it a variable
			cue=( "${dir}"/*.[Cc][Uu][Ee] )
			cue="${cue[0]}"

			# Load and store CUE into array
			__cue_array

			# Load and store CUE filenames
			__cue_filename

			# Check for missing files that are in ${file_array[@]}
			__check_missing_files

			# The CUE is stored as a single index in an array
			cue=( "$(printf "%s\n" "${cue_array[@]}")" )

			# Add the operation to run to the array.  '-c' is 1
			operations+=( "${dir} ::::@@si@@:::: ${cue}" )

			# Clear arrays below in the event other files may be found.  This
			# is explicitly called on this operation because the multiple files
			# operations already clear the arrays when calling '__cue_split'
			cue=()
			cue_array=()
		fi

		#== .: END SINGLE FILE -- SINGLE/MULTIPLE CUE :. =======================

		# Clear the total files found for this directory so it doesn't
		# pollute the next loop
		tmp_total_files=()

		# Clear the multiple CUE array in the event that multiple
		# directories have multiple files in a CUE
		multi_cue=()
	done
}

#== .: END PRELIMINARY OPERATIONS :. ===========================================


#-------------------------------------------------------------------------------
# .: SUB OPERATIONS :.
#-------------------------------------------------------------------------------
# Create split files directory using tags obtained from the CUE file
__create_split_dir () {
	# If the tags to use for directory names are NULL, set placeholder values
	#
	# We set a temporary tag to use to make the directory heirarchy in order to
	# not pollute testing against NULL tag values when setting the tags for the
	# split FLAC files

	if [[ -z "${ARTIST}" ]] ; then
		dir_artist="[Unknown Artist]"
	else
		dir_artist="${ARTIST}"
	fi

	# Both DATE and ALBUM are NULL
	if [[ -z "${DATE}" && -z "${ALBUM}" ]] ; then
		dir_date="[0000] - "
		dir_album="[Unknown Album]"

	# Only DATE is NULL.  Don't display DATE
	elif [[ -z "${DATE}" && -n "${ALBUM}" ]] ; then
		dir_date=""
		dir_album="${ALBUM}"

	# Only ALBUM is NULL
	elif [[ -z "${ALBUM}" && -n "${DATE}" ]] ; then
		dir_date="[${DATE}] - "
		dir_album="[Unknown Album]"

	# Both DATE and ALBUM are NOT NULL
	else
		dir_date="[${DATE}] - "
		dir_album="${ALBUM}"
	fi

	# This variable is used for splitting and tagging files as well
	full_split_dir="${split_dir}/${dir_artist}/${dir_date}${dir_album}"

	# Create the directories
	mkdir -p "${full_split_dir}"
}

# Decode the image file into WAV, if not already a WAV file
__decode_file () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Decode file into WAV using the right tool based off of the file extension
	case "${extension}" in
		[Aa][Pp][Ee])
			mac "${dir}/${i}" "${full_split_dir}/${i%.*}_tmp_si_$$.wav" -d >/dev/null 2>&1

			# Set $i to the decoded file
			i="${full_split_dir}/${i%.*}_tmp_si_$$.wav"
		;;
		[Ww][Vv])
			wvunpack -q "${dir}/${i}" -o "${full_split_dir}/${i%.*}_tmp_si_$$.wav"

			# Set $i to the decoded file
			i="${full_split_dir}/${i%.*}_tmp_si_$$.wav"
		;;
		*)
			# Set the full pathname to $i
			i="${dir}/${i}"
		;;
	esac
}

# Split image file with `flac'
__split_file () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Clear the below arrays to ensure they are not polluted with previous files
	title_array=()
	tracknumber_array=()
	split_indices=()
	sorted_split_indices=()
	starting_split_point=""
	ending_split_point=""

	# Grab the tracknumber, title, and split points to use from the CUE array
	#
	# TRACKNUMBER
	for line in "${cue_array[@]}" ; do
		if [[ "${line}" == '  TRACK'* ]] ; then
			tracknumber_line="${line##*TRACK }"
			tracknumber_array+=( "${tracknumber_line%% *}" )
		fi
	done

	# TITLE
	for line in "${cue_array[@]}" ; do
		if [[ "${line}" == '    TITLE'* ]] ; then
			title_line="${line#*TITLE*\"}"
			title_array+=( "${title_line%\"*}" )
		fi
	done

	for line in "${!cue_array[@]}" ; do
		if [[ "${cue_array[${line}]}" == '  TRACK'* ]] ; then
			# eg. '  TRACK 04 AUDIO' -> 04
			split_track="${cue_array[${line}]##*TRACK }"

			# eg. '04 AUDIO' -> 04
			split_track="${split_track%% *}"

			# eg. '04' -> 4
			split_track="${split_track#0}"

			if [[ "${cue_array[$(( line + 1 ))]}" == '    INDEX 0'* ]] ; then
				if [[ "${cue_array[$(( line + 1 ))]}" == '    INDEX 00'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 2 ))]##* }" )

					# eg. 3.end:::09:15.444
					split_indices+=( "$(( split_track - 1 )).end::::${cue_array[$(( line + 1 ))]##* }" )
				elif [[ "${cue_array[$(( line + 1 ))]}" == '    INDEX 01'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 1 ))]##* }" )
				fi

			elif [[ "${cue_array[$(( line + 2 ))]}" == '    INDEX 0'* ]] ; then
				if [[ "${cue_array[$(( line + 2 ))]}" == '    INDEX 00'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 3 ))]##* }" )

					# eg. 3.end:::09:15.444
					split_indices+=( "$(( split_track - 1 )).end::::${cue_array[$(( line + 2 ))]##* }" )
				elif [[ "${cue_array[$(( line + 2 ))]}" == '    INDEX 01'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 2 ))]##* }" )
				fi

			elif [[ "${cue_array[$(( line + 3 ))]}" == '    INDEX 0'* ]] ; then
				if [[ "${cue_array[$(( line + 3 ))]}" == '    INDEX 00'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 4 ))]##* }" )

					# eg. 3.end:::09:15.444
					split_indices+=( "$(( split_track - 1 )).end::::${cue_array[$(( line + 3 ))]##* }" )
				elif [[ "${cue_array[$(( line + 3 ))]}" == '    INDEX 01'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 3 ))]##* }" )
				fi

			elif [[ "${cue_array[$(( line + 4 ))]}" == '    INDEX 0'* ]] ; then
				if [[ "${cue_array[$(( line + 4 ))]}" == '    INDEX 00'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 5 ))]##* }" )

					# eg. 3.end:::09:15.444
					split_indices+=( "$(( split_track - 1 )).end::::${cue_array[$(( line + 4 ))]##* }" )
				elif [[ "${cue_array[$(( line + 4 ))]}" == '    INDEX 01'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 4 ))]##* }" )
				fi

			elif [[ "${cue_array[$(( line + 5 ))]}" == '    INDEX 0'* ]] ; then
				if [[ "${cue_array[$(( line + 5 ))]}" == '    INDEX 00'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 6 ))]##* }" )

					# eg. 4.end:::12:34.826
					split_indices+=( "$(( split_track - 1 )).end::::${cue_array[$(( line + 5 ))]##* }" )
				elif [[ "${cue_array[$(( line + 5 ))]}" == '    INDEX 01'* ]] ; then
					# eg. 4.start:::09:17.444
					split_indices+=( "${split_track}.start::::${cue_array[$(( line + 5 ))]##* }" )
				fi
			fi
		fi
	done

	# Sort the obtained tracknumber and split point into a new array called:
	#   sorted_split_indices
	for index in "${!tracknumber_array[@]}" ; do
		for track in "${split_indices[@]}" ; do
			if [[ "${track}" == *'.start::::'* ]] ; then
				track_num="${track%%.start::::*}"
			else
				track_num="${track%%.end::::*}"
			fi

			if (( (index + 1) == track_num )) ; then
				sorted_split_indices+=( "${track}" )
			fi
		done
	done

	# For each index in the TITLE array, store the split points into an array
	# to be used by `flac'
	for num in "${!title_array[@]}" ; do
		current_tracknumber="$(( num + 1 ))"

		for split_point in "${!sorted_split_indices[@]}" ; do

			if (( ${sorted_split_indices[${split_point}]%%.*::::*} == current_tracknumber )) ; then

				if [[ "${sorted_split_indices[${split_point}]%%::::*}" == "${current_tracknumber}.start" ]] ; then
					starting_split_point="${sorted_split_indices[${split_point}]##*::::}"
					ending_split_point="${sorted_split_indices[$(( split_point + 1 ))]##*::::}"

					if [[ "${sorted_split_indices[$(( split_point + 1 ))]%%::::*}" == "${current_tracknumber}.end" ]] ; then
						starting_split_check="${sorted_split_indices[$(( split_point + 2 ))]##*::::}"
						starting_split_check="${starting_split_check%%:*}"
						starting_split_check="${starting_split_check#0}"

						ending_split_check="${ending_split_point%%:*}"
						ending_split_check="${ending_split_check#0}"

						if (( (starting_split_check - ending_split_check) > 0 )) ; then
							ending_split_point="${sorted_split_indices[$(( split_point + 2 ))]##*::::}"
						else
							starting_index_seconds="${sorted_split_indices[$(( split_point + 2 ))]##*::::}"
							starting_index_seconds="${starting_index_seconds#*:}"
							starting_index_seconds="${starting_index_seconds%.*}"

							ending_index_seconds="${ending_split_point#*:}"
							ending_index_seconds="${ending_index_seconds%.*}"

							if (( (starting_index_seconds - ending_index_seconds) > 2 )) ; then
								ending_split_point="${sorted_split_indices[$(( split_point + 2 ))]##*::::}"
							fi
						fi
					fi
				fi
				break
			fi
		done

		# Obtain track number
		printf -v track_number %02d $(( 10#${tracknumber_array[${num}]} ))

		# Obtain track title (filename)
		track_title="${title_array[${num}]}.flac"

		if [[ -n "${ending_split_point}" ]] ; then
			flac \
				--totally-silent \
				-V \
				-0 \
				--skip="${starting_split_point}" \
				--until="${ending_split_point}" \
				"${i}" \
				-o "${full_split_dir}/${track_number} - ${track_title}"
		else
			flac \
				--totally-silent \
				-V \
				-0 \
				--skip="${starting_split_point}" \
				"${i}" \
				-o "${full_split_dir}/${track_number} - ${track_title}"
		fi
	done

	# Remove temporary WAV file (if applicable)
	rm -f "${full_split_dir}"/**/*_tmp_si_[0-9]*.wav
}

# Tag the split music files
__tag_files () {
	# Initialize array to empty to keep other runs from polluting the array
	metaflac_tags=()

	# Build the album tags to set (for metaflac) based on which tags were found.
	# The indices for each of the tags is as follows (this is the order in which
	# the tags will be set):
	#   [0] TITLE
	#   [1] ARTIST
	#   [2] ALBUM
	#   [3] DATE
	#   [4] TRACKNUMBER
	#   [5] GENRE
	#
	# [1] ARTIST
	if [[ -n "${ARTIST}" ]] ; then
		metaflac_tags[1]="--set-tag=ARTIST=${ARTIST}"
	fi

	# [2] ALBUM
	if [[ -n "${ALBUM}" ]] ; then
		metaflac_tags[2]="--set-tag=ALBUM=${ALBUM}"
	fi

	# [3] DATE
	if [[ -n "${DATE}" ]] ; then
		metaflac_tags[3]="--set-tag=DATE=${DATE}"
	fi

	# [5] GENRE
	if [[ -n "${GENRE}" ]] ; then
		metaflac_tags[6]="--set-tag=GENRE=${GENRE}"
	fi

	# Run through the CUE array and grab the TITLE and split points of each
	# song, storing them into their own arrays
	for line in "${!cue_array[@]}" ; do
		if [[ "${cue_array[${line}]}" == '    TITLE'* ]] ; then
			# [0] TITLE
			title_tag="${cue_array[${line}]#*TITLE*\"}"
			title_tag="${title_tag%\"*}"
			metaflac_tags[0]="--set-tag=TITLE=${title_tag}"

			# [4] TRACKNUMBER - normally one line above TITLE, but could be a
			# few lines above
			#
			# 1 line above
			if [[ "${cue_array[$(( ${line} - 1 ))]}" == '  TRACK'* ]] ; then
				tracknumber_tag="${cue_array[$(( ${line} - 1 ))]##*TRACK }"

			# 2 lines above
			elif [[ "${cue_array[$(( ${line} - 2 ))]}" == '  TRACK'* ]] ; then
				tracknumber_tag="${cue_array[$(( ${line} - 2 ))]##*TRACK }"

			# 3 lines above
			elif [[ "${cue_array[$(( ${line} - 3 ))]}" == '  TRACK'* ]] ; then
				tracknumber_tag="${cue_array[$(( ${line} - 3 ))]##*TRACK }"

			# 4 lines above
			elif [[ "${cue_array[$(( ${line} - 4 ))]}" == '  TRACK'* ]] ; then
				tracknumber_tag="${cue_array[$(( ${line} - 4 ))]##*TRACK }"

			# 5 lines above
			elif [[ "${cue_array[$(( ${line} - 5 ))]}" == '  TRACK'* ]] ; then
				tracknumber_tag="${cue_array[$(( ${line} - 5 ))]##*TRACK }"
			fi

			printf -v tracknumber_tag %02d $(( 10#${tracknumber_tag%% *} ))
			metaflac_tags[4]="--set-tag=TRACKNUMBER=${tracknumber_tag}"

			# Tag the current FLAC file with the obtained tags
			metaflac \
				--remove-all-tags \
				"${metaflac_tags[@]}" \
				"${full_split_dir}/${tracknumber_tag} - ${title_tag}.flac"
		fi
	done
}

#== .: END SUB OPERATIONS :. ===================================================


#-------------------------------------------------------------------------------
# .: SPLITTING OPERATIONS :.
#-------------------------------------------------------------------------------
# Operation to split files in parallel, obtaining the information from $@
__operation_split () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive SIGTERM from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Set up current directory from $@
	dir="${@% ::::@@si@@::::*}"

	# Set the CUE information from ${tmp_parameter} into the CUE array
	mapfile -n0 -t cue_array <<< "${@##*::::@@si@@:::: }"

	# Check if CUE is neither ASCII or UTF8.  If not, then try to encode to
	# UTF8, to help process files.  Normally, if not ASCII or UTF8, the encoding
	# is CP1251 (Russian/Cyrillic), so we'll use CP1251 as the encoding from
	# parameter to 'iconv'
	__cue_encoding

	# Run through CUE array and replace certain characters
	# Characters replaced:
	#   ` -> '
	__cue_replace_characters

	# Run through CUE array and obtain album tags and the current file to
	# process
	for line in "${cue_array[@]}" ; do
		# Obtain filename
		__cue_current_filename

		# Obtain ARTIST
		__cue_artist

		# Obtain ALBUM
		__cue_album

		# Obtain DATE
		__cue_date

		# Obtain GENRE
		__cue_genre
	done

	# Set ${i} from the file found from __cue_current_filename
	i="${file}"

	# Convert the CUE file from frames per seconds to milliseconds to allow
	# `flac' to understand the split points being used
	__cue_milliseconds

	# Display spinner only once as it will always be running
	if (( count == 1 )) ; then
		# Display spinner as a separate process (forked to background)
		__spinner &

		# Store spinner PID into fd '4'
		printf "%s\n" "${!}" >&4
	fi

	# Display current file being split
	__print_splitting_file

	# Create split files directory using tags obtained from the CUE array
	__create_split_dir

	# Decode the image file to WAV (if not already a WAV file)
	__decode_file

	# Split image file with 'flac'
	__split_file

	# Tag the split music files
	__tag_files

	# Print newline into file descriptor after completion
	__newline >&3
}

#== .: END SPLITTING OPERATIONS :. =============================================


#-------------------------------------------------------------------------------
# .: PRE-SCRIPT CHECKS :.
#-------------------------------------------------------------------------------
# Current program version
version="0.2"

# Colors
blue="\033[34m"
green="\033[32m"
red="\033[31m"
cyan="\033[36m"
magenta="\033[35m"
yellow="\033[33m"
normal="\033[0m"

# Process positional parameters, allowing script to see which operations to run.
# Make sure we send all the positional parameters called to the function,
# otherwise the function will think there aren't any positional parameters to
# process as it handles it's own positional parameters
__process_positional_parameters "${@}"

# Check if user set '-n, --no-color'.  This must come before everything (and
# after the positional parameters) to ensure color is set/unset
if [[ "${no_color}" == "true" ]] ; then
    blue=""
    green=""
    red=""
    cyan=""
    magenta=""
    yellow=""
    normal=""
fi

# Make sure we are running BASH 4 or greater
bash_version_check="${BASH_VERSION%%.*}"
if (( bash_version_check < 4 )) ; then
    { __error "You must be running BASH version 4 or greater to use" ; __newline ;} >&2
    { __error "this program!" ; __newline ;} >&2
    exit 1
fi

# Check for any missing programs vital for this script to operate correctly, and
# exit if any programs are found to be missing
__check_missing_programs

# Check whether directories exists
if (( ${#} >= 2 )) ; then
	if [[ ! -d "${image_dir}" && ! -d "${split_dir}" ]] ; then
		__usage >&2
		{ __error "Please specify a directory to process AND a directory to place split files!" ; __newline ;} >&2
		exit 1
	elif [[ ! -d "${image_dir}" && -d "${split_dir}" ]] ; then
		__usage >&2
		{ __error "Please specify a directory to process!" ; __newline ;} >&2
		exit 1
	elif [[ -d "${image_dir}" && ! -d "${split_dir}" ]] ; then
		__usage >&2
		{ __error "Please specify a directory to place split files!" ; __newline ;} >&2
		exit 1
	fi
else
	__usage >&2
	{ __error "Please specify a directory to process AND a directory to place split files!" ; __newline ;} >&2
	exit 1
fi

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
else
	jobs_display="(User Defined)"
fi

#== .: END PRE-SCRIPT CHECKS :. ================================================


#-------------------------------------------------------------------------------
# .: BEGIN SCRIPT :.
#-------------------------------------------------------------------------------
# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2>/dev/null

# Hide the cursor
printf "\033[?25l"

# Temporary FIFO location
tmp_fifo="/tmp/si_tmp_fifo_$$"

# Temporary spinner FIFO
spinner_fifo="/tmp/si_spinner_fifo_$$"

# Shnsplit flac encoder to use:
#   No SEEKTABLE block created
#   Fastest/Lowest compression: 1
#   Verify FLAC output (tests integrity)
#   Output to shnsplit as '%f' which is sent as STDOUT to shnsplit as STDIN
shn_flac_enc="flac flac --no-seektable -1 -V -o %f -"

# Open up file descriptor '4' for reading and writing for use with the spinner
__create_spinner_fd

# Display top banner
__top_banner

# Obtain all the audio files (that may be processed)
__obtain_audio_files

# Length of the total number of music images to split
total_files_length="${#total_files[@]}"
total_files_length="${#total_files_length}"

# Obtain all the directories housing the music images to process
__obtain_directories

# Process music image files
if [[ -z "${total_files[@]}" ]] ; then
	{ __warn "There are not any music images to process!" ; __newline ;} >&2
else
	# Trap SIGINT (Control-C) to abort cleanly
	trap '__operation_abort 2>/dev/null' SIGINT

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Determine which operation should be run for each directory of audio files
	# stored in an array ${operations_to_run} which will be used to process all
	# the files in parallel
	__determine_operation

	# This displays '[ ok ]' after 'Finding music image files to process...'
	__processed_files_ok

	__newline

	# Run parallel operations, that which is specified as ${1}
	__run_parallel

	if [[ "${last_operation}" == "true" ]] ; then
		# Music image split successfully, printing only if it's the last file
		__print_splitting_ok ; __newline
	fi
fi

__operation_summary

#== .: END SCRIPT :. ===========================================================
