#!/bin/bash
#-------------------------------------------------------------------------------
# si - Parallel BASH commandline music image splitter to separate FLAC files
#-------------------------------------------------------------------------------
# Copyright (C) 2013  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/si
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#-------------------------------------------------------------------------------
# Enable BASH globstar
shopt -s globstar

# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2>/dev/null

# Hide the cursor
printf "\033[?25l"

# Current program version
version="0.1"

# Colors
blue="\033[34m"
green="\033[32m"
red="\033[31m"
cyan="\033[36m"
magenta="\033[35m"
yellow="\033[33m"
normal="\033[0m"

# Temporary FIFO location
tmp_fifo="/tmp/split_images_fifo_$$"

# Directory housing music image files
image_dir="${1%/}"

# Directory where split music file end up
split_dir="/media/Music_Library/Music/Split Music Files"

# Shnsplit flac encoder to use:
#  No SEEKTABLE block created
#  Fastest/Lowest compression: 1
#  Verify FLAC output (tests integrity)
#  Output to shnsplit as '%f' which is sent as STDOUT to shnsplit as STDIN
shn_flac_enc="flac flac --no-seektable -1 -V -o %f -"

# Red message
__error () {
	printf "${normal}%s${red}%s${normal}%s" \
	" " "*" " ${@}"
}

# Yellow message
__warn () {
	printf "${normal}%s${yellow}%s${normal}%s" \
	" " "*" " ${@}"
}

# Green message
__info () {
	printf "${normal}%s${green}%s${normal}%s" \
	" " "*" " ${@}"
}

# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${retag_flac}" == "true" ]] ; then
		__newline 2
	fi

	# Top title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"

	# Title
	printf "${normal}%s\n" \
	"                Runtime Information"

	# Bottom title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Script version
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"                  Version " "|" " " "${version}"

	# Processes to be used
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}%s${cyan}%s${normal}\n" \
	"            Parallel Jobs " "|" " " "${jobs}" " " "${jobs_display}"

	# Bottom banner line
	printf "${normal}%s${blue}%s${normal}\n\n" \
	" " "-------------------------+-------------------------"

	# Message indicating the searching of FLAC files
	__info "Finding music image files to process..."
}

# Display the summary of operations chart
__operation_summary () {
	# Title
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"
	printf "${normal}%s\n" \
	"            Number Of Music Images Split"
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	if [[ -z "${flac_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"              " "FLAC Images" " " "|" " " "${#flac_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"              " "FLAC Images" " " "|" " " "${#flac_files[@]}"
	fi

	if [[ -z "${wav_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"               " "WAV Images" " " "|" " " "${#wav_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"               " "WAV Images" " " "|" " " "${#wav_files[@]}"
	fi

	if [[ -z "${ape_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"               " "APE Images" " " "|" " " "${#ape_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"               " "APE Images" " " "|" " " "${#ape_files[@]}"
	fi

	if [[ -z "${wv_files[@]}" ]] ; then
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
		"                " "WV Images" " " "|" " " "${#wv_files[@]}"
	else
		printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
		"                " "WV Images" " " "|" " " "${#wv_files[@]}"
	fi

	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	#--------------------------------------------------------------------------
	# :: CLEANUP SECTION ::
	#--------------------------------------------------------------------------
	# Restore old stty settings, make stty happy by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	#== :: END CLEANUP SECTION :: =============================================
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_files_ok () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"
	columns="${columns/%;*}"

	# ${images_ok_spacing} is the spacing from the number of
	# ${columns} minus the number of printed characters:
	#
	#  * Finding music iamge files to process... <- ${images_ok_spacing} -> [ ok ]
	#                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
	# 42 is the number of printed characters printed and is what is subtracted
	# from ${columns} to get ${images_ok_spacing}:
	#
	#  ' * Finding music image files to process...'  (42 characters)
	#                                     '[ ok ] '  ( 7 characters)
	printf "${normal}%$(( ${columns} - 49 ))s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}" \
	"" "[" " " "ok" " " "]"
}

# Prints the number of newlines specified
# by ${1}
__newline () {
	newlines="${1}"

	# If ${newlines} is empty, set to 1 in order
	# to allow one newline to be printed
	if [[ -z "${newlines}" ]] ; then
		newlines="1"
	fi

	# Print the number of newlines specified
	for (( count=0; count < ${newlines}; count++ )) ; do
		printf "\n"
	done
}

#-------------------------------------------------------------------------------
#  PROCESSED FILE MESSAGES
#-------------------------------------------------------------------------------
# Print out current file that is being split
__print_splitting_file () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of files processed
	#  ${total_files_length}:  Length of the total # of files to split
	#                     29:  Length of:
	#                            [ Splitting Image ] (19)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#count} - ${total_files_length} - 29 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${count}/${#total_files[@]}]" " ${filename} " "" "[" " " "Splitting Image" " " "]" " "
}

# Print ok message
__print_ok () {
	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of files processed
	#  ${total_files_length}:  Length of the total # of files to split
	#                     16:  Length of:
	#                            [ ok ] (6)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( $(__columns) - ${#count} - ${total_files_length} - 16 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${count}/${#total_files[@]}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# This is the function to run when a user invokes SIGINT during an operation
__operation_abort () {
	__newline
	__info "Control-C received. Please wait..." ; __newline

	# Kill running children
	__kill_jobs

	# Remove any temporary WAV files (if any)
	rm -f "${image_dir}"/**/\[[0-9]*\]_tmp_si_[0-9]*.wav

	# Restore old stty settings, make stty happy by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Restore the cursor
	printf "\033[?25h"

	exit 1
}

# Determine the width of the terminal in columns
__columns () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"

	# Prints out total columns of terminal
	printf "%s" "${columns/%;*}"
}

# Display current length spacing between filename and operation message
__current_length () {
	# The current length is obtained via the length of what's printed now minus
	# the length of the filename and gaps:
	#
	#  [1234/123456] 07 - Some_FLAC_Filename.flac <- ${current_length} -> [ Operation Message ]
	#                                             ^^^^^^^^^^^^^^^^^^^^^^^
	#  ${current_filename_length}:  Length of the current filename from __filename
	#  ${max_filename_length} + 1:  Total length of what's printed minus the operation
	#                               message plus one because we do not want the ellipsis
	#                               from ${max_filename_length}, just the space/gap
	#
	# Only print out ${current_length} if the current filename length is less
	# than the maximum file length allowed
	if [[ "${current_filename_length}" -lt "${max_filename_length}" ]] ; then
		printf "%s" "$(( ${max_filename_length} - ${current_filename_length} + 1 ))"
	fi
}

# Creates filename of current FLAC and culls it if the length
# is bigger than then width of the terminal
__filename () {
	filename="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	filename="${filename//$'\n'/?}"

	# Obtain filename length.  We cannot use ${#filename} in the event there is
	# multibyte characters -- the width would not be equal to characters since
	# the characters can take up more than one block in a terminal
	current_filename_length="$(wc -L <<< "${filename}")"

	# Cull filename and add an ellipsis if the filename is too long
	if [[ "${current_filename_length}" -gt "${max_filename_length}" ]] ; then
		filename="${filename::${max_filename_length}}…"
	fi
}

# Kill any child process
__kill_jobs () {
	# Hide error output in case there are no children to kill
	kill $(jobs -rp) 2>/dev/null

	# Wait on killing the children process, hiding STDERR to disable job control
	# output
	wait "${!}" 2>/dev/null
}

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if [[ "$(stat -c %d%D /proc)" == "$(stat -c %d%D /)" ]] ; then
		# /proc is not mounted, default to 2 jobs
		jobs_display="(Default)"
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs_display="(Default)"
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
			jobs_display="(/proc/cpuinfo)"
		fi
	fi
}

# Clear old file descriptor (3) and create a new
# FIFO that's tied to file discriptor 3, removing
# the FIFO upon completion
__clear_tmp_fd () {
	# Create temporary FIFO
	mkfifo "${tmp_fifo}"

	# Open FIFO for reading and writing on file descriptor '3'
	exec 3<>"${tmp_fifo}"

	# Remove temporary FIFO and leave just the file
	# descriptor available
	rm -f "${tmp_fifo}"
}

# Function to run operations in parallel
__run_parallel () {
	# Forces count to start at 0, in the event that
	# multiple operations are going to be run
	count=0

	# Start as many processes as determined by ${jobs}
	for process in "${operations[@]:0:${jobs}}" ; do

		((count++))

		# Run the split operation
		__operation_split "${process}" &

		((iteration++))

	done

	# If the operations to process are greater than the # of ${jobs} available,
	# continue processing them, else quit
	if [[ "${#operations[@]}" -gt "${jobs}" ]] ; then

		# After each newline is read from FIFO, start a new process
		while read ; do

			# If current number of operations to process is less than total
			# operations available, add another operation to process
			if [[ "${iteration}" -lt "$(( ${#operations[@]} - 1 ))" ]] ; then

				((count++))

				# Run the split operation
				__operation_split "${operations[${iteration}]}" &

				((iteration++))

			# Below is processed only if the current process ie equal to the
			# last ${operations_to_run} index
			else

				last_operation="true"

				((count++))

				# Run the split operation
				__operation_split "${operations[${iteration}]}" &

				((iteration++))

				# Break out of loop to prevent hanging FIFO
				break
			fi
		done <&3
	else
		last_operation="true"
	fi

	# Wait for children processes
	wait
}

# Grab the CUE header to allow each separate CUE to have the requisite
# information
__cue_header () {
	# Run through CUE array and store the first lines of the CUE file until the
	# first FILE is found.  This is the CUE header
	for line in "${!cue_array[@]}" ; do
		if [[ "${cue_array[${line}]}" != FILE* ]] ; then
			# Store the current line into array
			cue_header+=( "${cue_array[${line}]}" )

			# Store the index where the above line can be found
			# into an array
			cue_indices+=( "${line}" )
		else
			# The first file was listed in the CUE, so all the
			# header information has been obtained, break out of
			# the loop
			break
		fi
	done

	# Unset the header information from the CUE array
	for index in "${cue_indices[@]}" ; do
		unset -v cue_array[${index}]
	done

	# Remove empty indices by recreating/repacking array
	cue_array=( "${cue_array[@]}" )
}

# Load CUE array and remove carriage returns if any
__cue_array () {
	# Load up CUE into array
	mapfile -n0 -t cue_array < "${cue}"

	# Remove any carriage returns (if the CUE is from Windows)
	cue_array=( "${cue_array[@]//$'\r'/}" )
}

# Load filenames (FILE) from CUE file into array
__cue_filename () {
	# Check for multiple filenames in CUE array and store them in an
	# array
	for file in "${cue_array[@]}" ; do
		if [[ "${file}" == *FILE* ]] ; then
			file="${file#*FILE \"}"
			file="${file%\"*}"

			# Remove extension from file.  Loop twice for when a file name has
			# two extensions:
			#   <filename>.<WAV>.<EXTENSION>
			for ((i=1; i<3; i++)) ; do
				file="${file%.[Aa][Pp][Ee]}"
				file="${file%.[Ff][Ll][Aa][Cc]}"
				file="${file%.[Ww][Vv]}"
				file="${file%.[Ww][Aa][Vv]}"
			done

			# Compare each audio file in the current directory to the file found
			# in the CUE array.  If a match is found, add to ${file_array}
			for current_file in "${tmp_total_files[@]##*/}" ; do

				# Remove extensions from current file in the directory, looping
				# twice in the event a file has two extensions like above
				for ((j=1; j<3; j++)) ; do
					# ${i} is the ${current_file} with extensions removed
					i="${current_file%.[Aa][Pp][Ee]}"
					i="${i%.[Ff][Ll][Aa][Cc]}"
					i="${i%.[Ww][Vv]}"
					i="${i%.[Ww][Aa][Vv]}"
				done

				# Compare ${i} ( ${current_file} without extensions ), with the
				# file found in the CUE array
				if [[ "${i}" == "${file}" ]] ; then
					# ${current_file} is the filename WITH the extension
					file_array+=( "${current_file}" )
				fi
			done
		fi
	done
}

# Check for missing files that are in ${file_array[@]}
__check_missing_files () {
	# Check if all the files in the above array exist in the current
	# directory
	if [[ -n "${files_dont_exist[@]}" ]] ; then
		__error "In the directory:" ; __newline

		__error
			printf "%s${cyan}%s${normal}\n" \
			"  " "${dir}"

		__error ; __newline
		__error "The CUE file:" ; __newline

		__error
			printf "%s${cyan}%s${normal}\n" \
			"  " "${cue##*/}"

		__error ; __newline
		__error "Specifies one or more files to split that are NOT avaiable in the same" ; __newline
		__error "directory as the CUE file.  The missing file(s):" ; __newline

		for file in "${files_dont_exist[@]}" ; do
			printf "%s${red}%s${normal}%s${cyan}%s${normal}\n" \
			" " "*" "   " "${file}"
		done

		exit 1
	fi

	# Clear ${file_array} from __cue_filename as this function is the only
	# function that uses it
	file_array=()
}

# Split CUE file into separate CUE files, each CUE file separated by FILE.  Each
# file found in a CUE is separated into a separate CUE file
__split_cue () {
	# Initialize cue file iteration to zero
	cue_iteration=0

	# Until CUE array is 0 (meaning all the files have been
	# processed), continue splitting all the files in the
	# CUE array to separate CUE files
	until [[ ${#cue_array[@]} -eq 0 ]] ; do

		# Go through each line in the CUE array, storing the
		# lines for each file into a separate CUE file
		for line in "${!cue_array[@]}" ; do

			# If the current line has a file in it and is NOT
			# the first FILE in the CUE array, add one to CUE
			# iteration
			if [[ "${cue_array[${line}]}" == FILE* && ${line} -ne 0 ]] ; then
				# A new file is found in the CUE array, break
				# out of loop and add one to the number of
				# files found
				((cue_iteration++))
				break

			# If the index we are on is the last one of the
			# array, add one to the number of files found
			elif [[ ${line} -eq $(( ${#cue_array[@]} - 1 )) ]] ; then
				# End of array, add one to the number of files
				# found
				((cue_iteration++))

				# Store the index for removal
				file_indices+=( "${line}" )
				break

			# If the line to process is blank, store the index
			elif [[ -z "${cue_array[${line}]}" ]] ; then
				# Blank line, just store the index for removal
				file_indices+=( "${line}" )

			else
				# Store line into the new CUE array
				new_cue+=( "${cue_array[${line}]}" )

				# Store the index from where it was found
				file_indices+=( "${line}" )
			fi
		done

		# Add the CUE file (that was just split/obtained) to a new array as a
		# single index.  This will be used to loop over (each index is a CUE
		# file to process).  The quoted 'printf' command allows us to store
		# the CUE header and the entire ${new_cue} array as a single index
		multi_cue+=( "$(printf "%s\n%s\n" "${cue_header[@]}" "${new_cue[@]}")" )

		# Unset all the used indices
		for index in "${file_indices[@]}" ; do
			unset -v cue_array[${index}]
		done

		# Remove empty indices by recreating/repacking array
		cue_array=( "${cue_array[@]}" )

		# Clear arrays for next loop
		file_indices=()
		new_cue=()
		print_array=()
	done

	# Clear CUE header array in the event of more than one file to split
	cue_header=()
}

# Obtain filename from current CUE file
__current_file_from_cue () {
	# Grab file to process
	if [[ "${line}" == *FILE* ]] ; then
		file="${line#*FILE \"}"
		file="${file%\"*}"

		# Remove extension from file.  Loop twice for when a file name has
		# two extensions:
		#   <filename>.<WAV>.<EXTENSION>
		for ((i=1; i<3; i++)) ; do
			file="${file%.[Aa][Pp][Ee]}"
			file="${file%.[Ff][Ll][Aa][Cc]}"
			file="${file%.[Ww][Vv]}"
			file="${file%.[Ww][Aa][Vv]}"
		done

		# Obtain all the possible kinds of image files in the current directory
		tmp_wav_files=( "${dir}"/*.[Ww][Aa][Vv] )
		tmp_wv_files=( "${dir}"/*.[Ww][Vv] )
		tmp_flac_files=( "${dir}"/*.[Ff][Ll][Aa][Cc] )
		tmp_ape_files=( "${dir}"/*.[Aa][Pp][Ee] )

		# Test if there were any of the above file formats found, and if so add them
		# to the ${total_files[@]} array
		if [[ -f "${tmp_wav_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_wav_files[@]}" )
		fi

		if [[ -f "${tmp_wv_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_wv_files[@]}" )
		fi

		if [[ -f "${tmp_flac_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_flac_files[@]}" )
		fi

		if [[ -f "${tmp_ape_files[0]}" ]] ; then
			tmp_total_files+=( "${tmp_ape_files[@]}" )
		fi

		# Compare each audio file in the current directory to the file found
		# in the CUE array.  If a match is found, add to ${file_array}
		for current_file in "${tmp_total_files[@]##*/}" ; do

			# Remove extensions from current file in the directory, looping
			# twice in the event a file has two extensions like above
			for ((j=1; j<3; j++)) ; do
				# ${i} is the ${current_file} with extensions removed
				i="${current_file%.[Aa][Pp][Ee]}"
				i="${i%.[Ff][Ll][Aa][Cc]}"
				i="${i%.[Ww][Vv]}"
				i="${i%.[Ww][Aa][Vv]}"
			done

			# Compare ${i} ( ${current_file} without extensions ), with the
			# file found in the CUE array
			if [[ "${i}" == "${file}" ]] ; then
				# ${current_file} is the filename WITH the extension
				file=( "${current_file}" )
			fi
		done

		# Clear ${tmp_total_files}
		tmp_total_files=()
	fi
}

# Obtain ARTIST from current CUE file
__artist_from_cue () {
	# Grab ARTIST tag
	if [[ "${line}" == PERFORMER* ]] ; then
		ARTIST="${line#*\"}"
		ARTIST="${ARTIST%\"}"
	fi
}

# Obtain ALBUM from current CUE file
__album_from_cue () {
	# Grab ALBUM tag
	if [[ "${line}" == TITLE* ]] ; then
		ALBUM="${line#*\"}"
		ALBUM="${ALBUM%\"}"
	fi
}

# Obtain DATE from current CUE file
__date_from_cue () {
	# Grab DATE tag
	if [[ "${line}" == 'REM DATE'* ]] ; then
		DATE="${line#* * }"
	fi
}

# Obtain GENRE from current CUE file
__genre_from_cue () {
	# Grab GENRE tag
	if [[ "${line}" == 'REM GENRE'* ]] ; then
		GENRE="${line#* * }"
		GENRE="${GENRE#\"}"
		GENRE="${GENRE%\"}"
	fi
}

# Run through CUE array and add an extra period to the end of each track TITLE
# if that TITLE ends with a period (to prevent 'shnsplit' from NOT adding a
# period)
__check_title_period () {
	for line in "${cue_array[@]}" ; do
		if [[ "${line}" == '    TITLE'* ]] ; then
			# Strip everything but the last character (not including the quotes
			# that may be at the end)
			#
			# Remove the last quote
			line="${line%\"}"

			# Last character of the line
			last_char="${line:$(( ${#line} - 1 ))}"

			# Replace TITLE line with the same line only with an extra period
			# appended to the line (before the quote that would be at the end)
			if [[ "${last_char}" == "." ]] ; then
				check_title_period+=( "${line}.\"" )
			else
				check_title_period+=( "${line}" )
			fi
		else
			check_title_period+=( "${line}" )
		fi
	done

	# Store old version of ${cue_array[@]} (for use when tagging)
	old_array=( "${cue_array[@]}" )

	# Replace ${cue_array} with the values from ${check_title_period}
	cue_array=( "${check_title_period[@]}" )
}

# Create split files directory using tags obtained from the CUE file
__create_split_dir () {
	# If the tags to use for directory names are NULL, set placeholder values
	#
	# We set a temporary tag to use to make the directory heirarchy in order to
	# not pollute testing against NULL tag values when setting the tags for the
	# split FLAC files

	if [[ -z "${ARTIST}" ]] ; then
		dir_artist="[Unknown Artist]"
	else
		dir_artist="${ARTIST}"
	fi

	# Both DATE and ALBUM are NULL
	if [[ -z "${DATE}" && -z "${ALBUM}" ]] ; then
		dir_date="[0000] - "
		dir_album="[Unknown Album]"

	# Only DATE is NULL.  Don't display DATE
	elif [[ -z "${DATE}" && -n "${ALBUM}" ]] ; then
		dir_date=""
		dir_album="${ALBUM}"

	# Only ALBUM is NULL
	elif [[ -z "${ALBUM}" && -n "${DATE}" ]] ; then
		dir_date="[${DATE}] - "
		dir_album="[Unknown Album]"

	# Both DATE and ALBUM are NOT NULL
	else
		dir_date="[${DATE}] - "
		dir_album="${ALBUM}"
	fi

	# This variable is used for splitting and tagging files as well
	full_split_dir="${split_dir}/${dir_artist}/${dir_date}${dir_album}"

	# Create the directories
	mkdir -p "${full_split_dir}"
}

# Operation to split files in parallel, obtaining the information from $@
__operation_split () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive SIGTERM from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Set up current directory from positional parameters
	dir="${@% ::::@@si@@::::*}"

	# Set the CUE information from positional parameters into the CUE array
	mapfile -n0 -t cue_array <<< "${@#*::::@@si@@:::: }"

	# Run through CUE array and add an extra period to the end of each track
	# TITLE if that TITLE ends with a period (to prevent 'shnsplit' from NOT
	# adding a period)
	__check_title_period

	# Run through CUE array and obtain album tags and the current file to
	# process
	for line in "${cue_array[@]}" ; do

		# Obtain filename
		__current_file_from_cue

		# Obtain ARTIST
		__artist_from_cue

		# Obtain ALBUM
		__album_from_cue

		# Obtain DATE
		__date_from_cue

		# Obtain GENRE
		__genre_from_cue
	done

	# Set ${i} from the file found from __current_file_from_cue
	i="${file}"

	# Check if file has a higher resolution than a CD (eg. greater than
	# 16bit/44.1kHz) and if so, convert the CUE sheet array from frames
	# per second to milliseconds to allow shnsplit to work correctly
	__high_resolution

	# Display current file being split
	__print_splitting_file

	# Create split files directory using tags obtained from the CUE array
	__create_split_dir

	# Split image file with 'shnsplit' and send to background to allow killing
	# on SIGTERM
	__split_file &

	# Wait on background process and return exit code of said process
	wait "${!}"

	# Exit code 130 is SIGINT so only check for exit code '1'
	if [[ "${?}" -eq 1 ]] ; then
		__warn "Failed to split ${i#**/}." ; __newline
		__warn "${i#**/} may be corrupt." ; __newline
	fi

	# Tag the split music files
	__tag_files

	# Print newline into file descriptor after completion
	__newline >&3
}

# Obtain total files to process in the current directory
__total_files_directory () {
	# Obtain all the possible kinds of image files in the current directory
	tmp_wav_files=( "${dir}"/*.[Ww][Aa][Vv] )
	tmp_wv_files=( "${dir}"/*.[Ww][Vv] )
	tmp_flac_files=( "${dir}"/*.[Ff][Ll][Aa][Cc] )
	tmp_ape_files=( "${dir}"/*.[Aa][Pp][Ee] )

	# Test if there were any of the above file formats found, and if so add them
	# to the ${total_files[@]} array
	if [[ -f "${tmp_wav_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_wav_files[@]}" )
	fi

	if [[ -f "${tmp_wv_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_wv_files[@]}" )
	fi

	if [[ -f "${tmp_flac_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_flac_files[@]}" )
	fi

	if [[ -f "${tmp_ape_files[0]}" ]] ; then
		tmp_total_files+=( "${tmp_ape_files[@]}" )
	fi

	# Obtain all the CUE files in the current directory
	cue_files=( "${dir}"/*.[Cc][Uu][Ee] )

	if [[ ! -f "${cue_files[0]}" ]] ; then
		__newline 2 ; __error "In the directory:" ; __newline

		__error
			printf "%s${cyan}%s${normal}\n" \
			"  " "${dir}"

		__error ; __newline
		__error "There doesn't appear to be a CUE file in the above directory!"
		__newline 2

		exit 1
	fi
}

# Determine operation(s) to run
__determine_operation () {
	# Run through the total directories, determining which operation should be
	# performed based on the files found in each directory
	for dir in "${total_directories[@]}" ; do
		# Obtain total files to process in the current directory: ${dir}
		__total_files_directory

		# Check the number of CUE file and music image files in the current
		# directory, running a certain operation depending on the number(s)
		# found in the current directory
		#
		# If the number of music image files is GREATER than one
		if [[ ${#tmp_total_files[@]} -gt 1 ]] ; then

			# If the number of CUE files is GREATER than one
			if [[ ${#cue_files[@]} -gt 1 ]] ; then

				# Obtain all the CUE files in the current directory
				cue_files=( "${dir}"/*.[Cc][Uu][Ee] )

				for cue in "${cue_files[@]}" ; do
					# Load and store CUE into array
					__cue_array

					# Load and store CUE filenames
					__cue_filename

					# Check for missing files that are in ${file_array[@]}
					__check_missing_files
				done

				for cue in "${cue_files[@]}" ; do

					# Load and store CUE into array
					__cue_array

					# Grab the CUE header to allow each separate CUE to have the
					# requisite information
					__cue_header

					# Split CUE file in array into separate CUE files to be used to split each
					# file listed in the separate CUE files
					__split_cue

					for cue in "${multi_cue[@]}" ; do
						cue=( "$(printf "%s\n" "${cue}")" )
						operations+=( "${dir} ::::@@si@@:::: ${cue}" )
					done
				done

			else
				# Grab the path to the only CUE file and store it a variable
				cue=( "${dir}"/*.[Cc][Uu][Ee] )

				# Load and store CUE into array
				__cue_array

				# Load and store CUE filenames
				__cue_filename

				# Grab the CUE header to allow each separate CUE to have the
				# requisite information
				__cue_header

				# Check for missing files that are in ${file_array[@]}
				__check_missing_files

				# Split CUE file in array into separate CUE files to be used to split each
				# file listed in the separate CUE files
				__split_cue

				for cue in "${multi_cue[@]}" ; do
					cue=( "$(printf "%s\n" "${cue}")" )
					operations+=( "${dir} ::::@@si@@:::: ${cue}" )
				done
			fi

		# There is only one music image file in the current directory.  The number
		# of CUE files does not matter since one or more is handled the same way
		else

			# Grab the path to only one CUE file and store it a variable
			cue=( "${dir}"/*.[Cc][Uu][Ee] )
			cue="${cue[0]}"

			# Load and store CUE into array
			__cue_array

			# Load and store CUE filenames
			__cue_filename

			# Check for missing files that are in ${file_array[@]}
			__check_missing_files

			cue=( "$(printf "%s\n" "${cue_array[@]}")" )

			# Run operation
			operations+=( "${dir} ::::@@si@@:::: ${cue}" )

			# Clear arrays below in the event other files may be found.  This
			# is explicitly called on this operation because the multiple files
			# operations already clear the arrays when calling '__split_cue'
			cue=()
			cue_array=()
			file_array=()
		fi

		# Clear the total files found for this directory so it doesn't
		# pollute the next loop
		tmp_total_files=()

		# Clear the multiple CUE array in the event that multiple
		# directories have multiple files in a CUE
		multi_cue=()
	done
}

# Check for high resolution file and convert the INDEX time to milliseconds if
# necessary
__high_resolution () {
	# Obtain sample rate and bit depth from current file.  The order in which
	# the type of formats displayed is not governed by the order it was called
	# under '-show-entries'.  The order will always show 'sample_fmt' before
	# 'sample_rate'
	mapfile -n2 -t -s1 file_metadata < <(ffprobe -loglevel quiet -show_entries stream=sample_fmt,sample_rate "${dir}/${i}")

	# Bit depth (first index)
	bits="${file_metadata[0]#*=[A-Za-z]}"
	bits="${bits%[A-Za-z]}"

	# Sample rate (second index)
	sample_rate="${file_metadata[1]#*=}"

	# If sample rate and/or bit depth is higher than CD quality (16bit/44.1kHz)
	# change CUE format from 'mm:ss:ff' to 'mm:ss.nnn' (frames/sec to
	# milliseconds)
	if [[ "${sample_rate}" -gt 44100 || "${bits}" -gt 16 ]] ; then
		# Clear & initialize array
		high_res_cue=()

		# Run through the CUE array and for each line that is an INDEX, convert
		# the time from frames/sec to milliseconds storing the new index and CUE
		# sheet into a new array to be processed by 'shnsplit' as a temporary
		# CUE sheet
		for line in "${cue_array[@]}" ; do
			if [[ "${line}" == *INDEX* ]] ; then
				# Obtain just the time (eg 11:22:33) from the INDEX line
				index="${line##* }"

				# Store the INDEX line without the time (eg.
				# '    INDEX 01')
				index_string="${line% *}"

				# Minutes
				mm="${index%%:*}"

				# Seconds
				ss="${index#*:}"
				ss="${ss%:*}"

				# Frames (per second)
				ff="${index##*:}"

				# Milliseconds (converted from frames/sec)
				#   10#$(( ))             # Force base ten operation
				#   ( # of frames )       # Number of frames/sec
				#   * ( 1000 / 75 )       # Multiply by 1000 (milliseconds) and
				#                           divide by 75 frames
				#   printf -v nnn "%03d"  # Force a three digit number, prepended
				#                           with zeroes if less than three digits
				printf -v nnn "%03d" "$(( 10#$((  ( ${ff} * 1000 / 75 )  )) ))"

				# If milliseconds is greater than '999' (eg. '1234') then add
				# the first digit to seconds keep the last three digits as
				# milliseconds
				if [[ "${nnn}" -gt 999 ]] ; then
					# Add the first digit of milliseconds to seconds variable
					printf -v ss "%02d" "$(( 10#$((  ${ss#0} + ${nnn%???}  )) ))"

					# Cull the first digit of milliseconds
					nnn="${nnn#?}"
				fi

				# Store the INDEX line with new time into the high resolution array
				high_res_cue+=( "${index_string} ${mm}:${ss}.${nnn}" )
			else
				# Store the current line into the high resolution array
				high_res_cue+=( "${line}" )
			fi
		done

		# Set the CUE array to the high resolution version created
		cue_array=( "${high_res_cue[@]}" )
	fi
}

# Split image file with 'shnsplit'
__split_file () {
	# Let's make sure to kill running children if this function was aborted via
	# SIGINT.  This function will receive EXIT from the kill in the previous
	# trap
	trap __kill_jobs EXIT

	# Obtain the first TRACKNUMBER in the CUE array.  Used to configure
	# what number the first split file should be via 'shnsplit'
	for line in "${!cue_array[@]}" ; do
		if [[ "${cue_array[${line}]}" == '    TITLE'* ]] ; then
			# Grab the TRACKNUMBER, located one line above the TITLE line
			TRACKNUMBER="${cue_array[$(( ${line} - 1 ))]#*TRACK }"
			TRACKNUMBER="${TRACKNUMBER% *}"

			# Break out of loop since the first TRACKNUMBER was found
			break
		fi
	done

	# The below 'shnsplit' command splits the music image file:
	#
	#   -O always                 # Always overwrite files (if applicable)
	#   -q                        # Suppress STDOUT (STDERR still shown)
	#   -o "${shn_flac_enc}"      # Use defined FLAC encoder
	#   -f /dev/stdin < <( )      # CUE file to use.  The path to '/dev/stdin'
	#                               alleviates the need to use a physical CUE
	#                               file
	#   -c ${TRACKNUMBER}         # Start output of filename TRACKNUMBER at
	#                               specified TRACKNUMBER in the event that the
	#                               CUE is part of multiple CUE files to split
	#                               multiple files. 'shntool' does not correctly
	#                               use '%n' to mean the TRACKNUMBER in the CUE,
	#                               but to mean starting at 1 and sequentially
	#                               increasing
	#   -t '%n - %t'              # Split files named (eg. 03 - TITLE.flac)
	#   -d "${full_split_dir}"    # Output directory of split files
	#   "${dir}/${i}"             # Music image file to split

	shnsplit \
		-O always \
		-q \
		-o "${shn_flac_enc}" \
		-f /dev/stdin < <(printf "%s\n" "${cue_array[@]}") \
		-c "${TRACKNUMBER}" \
		-t '%n - %t' \
		-d "${full_split_dir}" \
		"${dir}/${i}"

	# Remove files with tracknumbers that are zero (eg '00'), since the CUE file
	# doesn't contain track information for pre-gap files
	rm -f "${full_split_dir}"/00*.flac
}

# Tag the split music files
__tag_files () {
	# Run through old CUE array and grab the TRACKNUMBER and TITLE tag to
	# determine which files to tag in the event that previous splitting placed
	# additional files in the current directory
	for line in "${!old_array[@]}" ; do
		if [[ "${old_array[${line}]}" == '    TITLE'* ]] ; then
			# Grab the TRACKNUMBER, located one line above the TITLE line
			TRACKNUMBER="${old_array[$(( ${line} - 1 ))]#*TRACK }"
			TRACKNUMBER="${TRACKNUMBER% *}"

			# Grab the TITLE/filename
			TITLE="${old_array[${line}]#* TITLE*\"}"
			TITLE="${TITLE%\"*}"

			# Store the current filename to tag into an array formatted as:
			#   TRACKNUMBER - filename.flac
			files_to_tag+=( "${TRACKNUMBER} - ${TITLE}.flac" )
		fi
	done

	# Build the album tags to set (for metaflac) based on which tags were found.
	# The indices for each of the tags is as follows (this is the order in which
	# the tags will be set):
	#   [0] TITLE
	#   [1] ARTIST
	#   [2] ALBUM
	#   [3] DATE
	#   [4] TRACKNUMBER
	#   [5] GENRE
	#
	# [1] ARTIST
	if [[ -n "${ARTIST}" ]] ; then
		metaflac_tags[1]="--set-tag=ARTIST=${ARTIST}"
	fi

	# [2] ALBUM
	if [[ -n "${ALBUM}" ]] ; then
		metaflac_tags[2]="--set-tag=ALBUM=${ALBUM}"
	fi

	# [3] DATE
	if [[ -n "${DATE}" ]] ; then
		metaflac_tags[3]="--set-tag=DATE=${DATE}"
	fi

	# [5] GENRE
	if [[ -n "${GENRE}" ]] ; then
		metaflac_tags[6]="--set-tag=GENRE=${GENRE}"
	fi

	for file in "${files_to_tag[@]}" ; do
		# Grab TITLE from current filename
		# [0] TITLE
		TITLE="${file#* - }"
		metaflac_tags[0]="--set-tag=TITLE=${TITLE%.flac}"

		# Grab TRACKNUMBER from current filename
		# [4] TRACKNUMBER
		metaflac_tags[4]="--set-tag=TRACKNUMBER=${file%% - *}"

		# Tag the current FLAC file with the obtained tags
		metaflac \
			"${metaflac_tags[@]}" \
			"${full_split_dir}/${file}"
	done

	# Clear ${files_to_tag} array in the event there are multiple files to split
	# in one directory
	files_to_tag=()

	# Clear ${metaflac_tags} array in order to not pollute the tags to set in
	# the event there are multiple files to split in one directory
	metaflac_tags=()
}

# Find all the various audio files to process, storing the found files in one
# centralized array
__obtain_audio_files () {
	wav_files=( "${image_dir}"/**/*.[Ww][Aa][Vv] )
	wv_files=( "${image_dir}"/**/*.[Ww][Vv] )
	flac_files=( "${image_dir}"/**/*.[Ff][Ll][Aa][Cc] )
	ape_files=( "${image_dir}"/**/*.[Aa][Pp][Ee] )

	# Test if there were any of the above file formats found, and if so add them
	# to the ${total_files[@]} array
	if [[ -f "${wav_files[0]}" ]] ; then
		total_files+=( "${wav_files[@]}" )
	else
		wav_files=()
	fi

	if [[ -f "${wv_files[0]}" ]] ; then
		total_files+=( "${wv_files[@]}" )
	else
		wv_files=()
	fi

	if [[ -f "${flac_files[0]}" ]] ; then
		total_files+=( "${flac_files[@]}" )
	else
		flac_files=()
	fi

	if [[ -f "${ape_files[0]}" ]] ; then
		total_files+=( "${ape_files[@]}" )
	else
		ape_files=()
	fi
}

# Obtain all the directories housing the music images to process
__obtain_directories () {
	for i in "${total_files[@]}" ; do
		if [[ "${processed_directory}" != "${i%/*}" ]] ; then
			total_directories+=( "${i%/*}" )
		fi
		processed_directory="${i%/*}"
	done
}

#------------------------------------------------------------------------------
# :: BEGIN SCRIPT ::
#------------------------------------------------------------------------------
# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
else
	jobs_display="(User Defined)"
fi

# Display top banner
__top_banner

# Obtain all the audio files (that may be processed)
__obtain_audio_files

# Length of the total number of music images to split
total_files_length="${#total_files[@]}"
total_files_length="${#total_files_length}"

# Obtain all the directories housing the music images to process
__obtain_directories

# Process music image files
if [[ -z "${total_files[@]}" ]] ; then
	{ __warn "There are not any music images to process!" ; __newline ;} >&2
else
	# Trap SIGINT (Control-C) to abort cleanly
	trap '__operation_abort 2>/dev/null' SIGINT

	# Make sure to clear file descriptor '3' before proceeding
	__clear_tmp_fd

	# Determine which operation should be run for each directory of audio files
	# stored in an array ${operations_to_run} which will be used to process all
	# the files in parallel
	__determine_operation

	# This displays '[ ok ]' after 'Finding music image files to process...'
	__processed_files_ok

	__newline
	__info "Splitting music image files..." ; __newline

	# Run parallel operations, that which is specified as ${1}
	__run_parallel

	if [[ "${last_operation}" == "true" ]] ; then
		# Music image split successfully, printing only if it's the last file
		__print_ok ; __newline
	fi
fi

__operation_summary

#== :: END SCRIPT :: ==========================================================
